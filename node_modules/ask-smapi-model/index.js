"use strict";
/*
* Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file
* except in compliance with the License. A copy of the License is located at
*
* http://aws.amazon.com/apache2.0/
*
* or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for
* the specific language governing permissions and limitations under the License.
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable */
var runtime = require("ask-sdk-model-runtime");
exports.runtime = runtime;
var BaseServiceClient = runtime.BaseServiceClient;
var LwaServiceClient = runtime.LwaServiceClient;
var createUserAgent = runtime.createUserAgent;
var services;
(function (services) {
    var skillManagement;
    (function (skillManagement) {
        /**
         *
        */
        var SkillManagementServiceClient = /** @class */ (function (_super) {
            __extends(SkillManagementServiceClient, _super);
            function SkillManagementServiceClient(apiConfiguration, authenticationConfiguration, customUserAgent) {
                if (customUserAgent === void 0) { customUserAgent = null; }
                var _this = _super.call(this, apiConfiguration) || this;
                _this.lwaServiceClient = new LwaServiceClient({
                    apiConfiguration: apiConfiguration,
                    authenticationConfiguration: authenticationConfiguration,
                    grantType: 'refresh_token',
                });
                _this.userAgent = createUserAgent("" + require('./package.json').version, customUserAgent);
                return _this;
            }
            /**
             * Returns information about a particular catalog.
             * @param {string} catalogId Provides a unique identifier of the catalog.
             */
            SkillManagementServiceClient.prototype.callGetCatalogV0 = function (catalogId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetCatalogV0';
                                // verify required parameter 'catalogId' is not null or undefined
                                if (catalogId == null) {
                                    throw new Error("Required parameter catalogId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('catalogId', catalogId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v0/catalogs/{catalogId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Successful operation.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Returns information about a particular catalog.
             * @param {string} catalogId Provides a unique identifier of the catalog.
             */
            SkillManagementServiceClient.prototype.getCatalogV0 = function (catalogId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetCatalogV0(catalogId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Lists all the uploads for a particular catalog.
             * @param {string} catalogId Provides a unique identifier of the catalog.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             */
            SkillManagementServiceClient.prototype.callListUploadsForCatalogV0 = function (catalogId, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, nextTokenValues, maxResultsValues, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callListUploadsForCatalogV0';
                                // verify required parameter 'catalogId' is not null or undefined
                                if (catalogId == null) {
                                    throw new Error("Required parameter catalogId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (nextToken != null) {
                                    nextTokenValues = Array.isArray(nextToken) ? nextToken : [nextToken];
                                    nextTokenValues.forEach(function (val) { return queryParams.push({ key: 'nextToken', value: val }); });
                                }
                                if (maxResults != null) {
                                    maxResultsValues = Array.isArray(maxResults) ? maxResults : [maxResults];
                                    maxResultsValues.forEach(function (val) { return queryParams.push({ key: 'maxResults', value: val.toString() }); });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('catalogId', catalogId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v0/catalogs/{catalogId}/uploads";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Successful operation.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Lists all the uploads for a particular catalog.
             * @param {string} catalogId Provides a unique identifier of the catalog.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             */
            SkillManagementServiceClient.prototype.listUploadsForCatalogV0 = function (catalogId, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callListUploadsForCatalogV0(catalogId, nextToken, maxResults)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Creates a new upload for a catalog and returns presigned upload parts for uploading the file.
             * @param {string} catalogId Provides a unique identifier of the catalog.
             * @param {v0.catalog.upload.CreateContentUploadRequest} createContentUploadRequest Defines the request body for updateCatalog API.
             */
            SkillManagementServiceClient.prototype.callCreateContentUploadV0 = function (catalogId, createContentUploadRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callCreateContentUploadV0';
                                // verify required parameter 'catalogId' is not null or undefined
                                if (catalogId == null) {
                                    throw new Error("Required parameter catalogId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'createContentUploadRequest' is not null or undefined
                                if (createContentUploadRequest == null) {
                                    throw new Error("Required parameter createContentUploadRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('catalogId', catalogId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v0/catalogs/{catalogId}/uploads";
                                errorDefinitions = new Map();
                                errorDefinitions.set(201, "Content upload created.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, createContentUploadRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Creates a new upload for a catalog and returns presigned upload parts for uploading the file.
             * @param {string} catalogId Provides a unique identifier of the catalog.
             * @param {v0.catalog.upload.CreateContentUploadRequest} createContentUploadRequest Defines the request body for updateCatalog API.
             */
            SkillManagementServiceClient.prototype.createContentUploadV0 = function (catalogId, createContentUploadRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callCreateContentUploadV0(catalogId, createContentUploadRequest)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Gets detailed information about an upload which was created for a specific catalog. Includes the upload's ingestion steps and a presigned url for downloading the file.
             * @param {string} catalogId Provides a unique identifier of the catalog.
             * @param {string} uploadId Unique identifier of the upload.
             */
            SkillManagementServiceClient.prototype.callGetContentUploadByIdV0 = function (catalogId, uploadId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetContentUploadByIdV0';
                                // verify required parameter 'catalogId' is not null or undefined
                                if (catalogId == null) {
                                    throw new Error("Required parameter catalogId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'uploadId' is not null or undefined
                                if (uploadId == null) {
                                    throw new Error("Required parameter uploadId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('catalogId', catalogId);
                                pathParams.set('uploadId', uploadId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v0/catalogs/{catalogId}/uploads/{uploadId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Successful operation.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Gets detailed information about an upload which was created for a specific catalog. Includes the upload's ingestion steps and a presigned url for downloading the file.
             * @param {string} catalogId Provides a unique identifier of the catalog.
             * @param {string} uploadId Unique identifier of the upload.
             */
            SkillManagementServiceClient.prototype.getContentUploadByIdV0 = function (catalogId, uploadId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetContentUploadByIdV0(catalogId, uploadId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Completes an upload. To be called after the file is uploaded to the backend data store using presigned url(s).
             * @param {string} catalogId Provides a unique identifier of the catalog.
             * @param {string} uploadId Unique identifier of the upload.
             * @param {v0.catalog.upload.CompleteUploadRequest} completeUploadRequestPayload Request payload to complete an upload.
             */
            SkillManagementServiceClient.prototype.callCompleteCatalogUploadV0 = function (catalogId, uploadId, completeUploadRequestPayload) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callCompleteCatalogUploadV0';
                                // verify required parameter 'catalogId' is not null or undefined
                                if (catalogId == null) {
                                    throw new Error("Required parameter catalogId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'uploadId' is not null or undefined
                                if (uploadId == null) {
                                    throw new Error("Required parameter uploadId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'completeUploadRequestPayload' is not null or undefined
                                if (completeUploadRequestPayload == null) {
                                    throw new Error("Required parameter completeUploadRequestPayload was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('catalogId', catalogId);
                                pathParams.set('uploadId', uploadId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v0/catalogs/{catalogId}/uploads/{uploadId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(202, "Accepted.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(409, "The request could not be completed due to a conflict with the current state of the target resource.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, completeUploadRequestPayload, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Completes an upload. To be called after the file is uploaded to the backend data store using presigned url(s).
             * @param {string} catalogId Provides a unique identifier of the catalog.
             * @param {string} uploadId Unique identifier of the upload.
             * @param {v0.catalog.upload.CompleteUploadRequest} completeUploadRequestPayload Request payload to complete an upload.
             */
            SkillManagementServiceClient.prototype.completeCatalogUploadV0 = function (catalogId, uploadId, completeUploadRequestPayload) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callCompleteCatalogUploadV0(catalogId, uploadId, completeUploadRequestPayload)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Lists catalogs associated with a vendor.
             * @param {string} vendorId The vendor ID.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults
             */
            SkillManagementServiceClient.prototype.callListCatalogsForVendorV0 = function (vendorId, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, nextTokenValues, maxResultsValues, vendorIdValues, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callListCatalogsForVendorV0';
                                // verify required parameter 'vendorId' is not null or undefined
                                if (vendorId == null) {
                                    throw new Error("Required parameter vendorId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (nextToken != null) {
                                    nextTokenValues = Array.isArray(nextToken) ? nextToken : [nextToken];
                                    nextTokenValues.forEach(function (val) { return queryParams.push({ key: 'nextToken', value: val }); });
                                }
                                if (maxResults != null) {
                                    maxResultsValues = Array.isArray(maxResults) ? maxResults : [maxResults];
                                    maxResultsValues.forEach(function (val) { return queryParams.push({ key: 'maxResults', value: val.toString() }); });
                                }
                                vendorIdValues = Array.isArray(vendorId) ? vendorId : [vendorId];
                                vendorIdValues.forEach(function (val) { return queryParams.push({ key: 'vendorId', value: val }); });
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v0/catalogs";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Successful operation.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Lists catalogs associated with a vendor.
             * @param {string} vendorId The vendor ID.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults
             */
            SkillManagementServiceClient.prototype.listCatalogsForVendorV0 = function (vendorId, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callListCatalogsForVendorV0(vendorId, nextToken, maxResults)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Creates a new catalog based on information provided in the request.
             * @param {v0.catalog.CreateCatalogRequest} createCatalogRequest Defines the request body for createCatalog API.
             */
            SkillManagementServiceClient.prototype.callCreateCatalogV0 = function (createCatalogRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callCreateCatalogV0';
                                // verify required parameter 'createCatalogRequest' is not null or undefined
                                if (createCatalogRequest == null) {
                                    throw new Error("Required parameter createCatalogRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v0/catalogs";
                                errorDefinitions = new Map();
                                errorDefinitions.set(201, "Catalog created.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, createCatalogRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Creates a new catalog based on information provided in the request.
             * @param {v0.catalog.CreateCatalogRequest} createCatalogRequest Defines the request body for createCatalog API.
             */
            SkillManagementServiceClient.prototype.createCatalogV0 = function (createCatalogRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callCreateCatalogV0(createCatalogRequest)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Lists the subscribers for a particular vendor.
             * @param {string} vendorId The vendor ID.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             */
            SkillManagementServiceClient.prototype.callListSubscribersForDevelopmentEventsV0 = function (vendorId, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, vendorIdValues, nextTokenValues, maxResultsValues, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callListSubscribersForDevelopmentEventsV0';
                                // verify required parameter 'vendorId' is not null or undefined
                                if (vendorId == null) {
                                    throw new Error("Required parameter vendorId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                vendorIdValues = Array.isArray(vendorId) ? vendorId : [vendorId];
                                vendorIdValues.forEach(function (val) { return queryParams.push({ key: 'vendorId', value: val }); });
                                if (nextToken != null) {
                                    nextTokenValues = Array.isArray(nextToken) ? nextToken : [nextToken];
                                    nextTokenValues.forEach(function (val) { return queryParams.push({ key: 'nextToken', value: val }); });
                                }
                                if (maxResults != null) {
                                    maxResultsValues = Array.isArray(maxResults) ? maxResults : [maxResults];
                                    maxResultsValues.forEach(function (val) { return queryParams.push({ key: 'maxResults', value: val.toString() }); });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v0/developmentEvents/subscribers";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Successful operation.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Lists the subscribers for a particular vendor.
             * @param {string} vendorId The vendor ID.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             */
            SkillManagementServiceClient.prototype.listSubscribersForDevelopmentEventsV0 = function (vendorId, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callListSubscribersForDevelopmentEventsV0(vendorId, nextToken, maxResults)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Creates a new subscriber resource for a vendor.
             * @param {v0.developmentEvents.subscriber.CreateSubscriberRequest} createSubscriberRequest Defines the request body for createSubscriber API.
             */
            SkillManagementServiceClient.prototype.callCreateSubscriberForDevelopmentEventsV0 = function (createSubscriberRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callCreateSubscriberForDevelopmentEventsV0';
                                // verify required parameter 'createSubscriberRequest' is not null or undefined
                                if (createSubscriberRequest == null) {
                                    throw new Error("Required parameter createSubscriberRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v0/developmentEvents/subscribers";
                                errorDefinitions = new Map();
                                errorDefinitions.set(201, "Created. Returns a URL to retrieve the subscriber in &#39;Location&#39; header.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, createSubscriberRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Creates a new subscriber resource for a vendor.
             * @param {v0.developmentEvents.subscriber.CreateSubscriberRequest} createSubscriberRequest Defines the request body for createSubscriber API.
             */
            SkillManagementServiceClient.prototype.createSubscriberForDevelopmentEventsV0 = function (createSubscriberRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callCreateSubscriberForDevelopmentEventsV0(createSubscriberRequest)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Deletes a specified subscriber.
             * @param {string} subscriberId Unique identifier of the subscriber.
             */
            SkillManagementServiceClient.prototype.callDeleteSubscriberForDevelopmentEventsV0 = function (subscriberId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callDeleteSubscriberForDevelopmentEventsV0';
                                // verify required parameter 'subscriberId' is not null or undefined
                                if (subscriberId == null) {
                                    throw new Error("Required parameter subscriberId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('subscriberId', subscriberId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v0/developmentEvents/subscribers/{subscriberId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Successful operation.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("DELETE", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Deletes a specified subscriber.
             * @param {string} subscriberId Unique identifier of the subscriber.
             */
            SkillManagementServiceClient.prototype.deleteSubscriberForDevelopmentEventsV0 = function (subscriberId) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callDeleteSubscriberForDevelopmentEventsV0(subscriberId)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Returns information about specified subscriber.
             * @param {string} subscriberId Unique identifier of the subscriber.
             */
            SkillManagementServiceClient.prototype.callGetSubscriberForDevelopmentEventsV0 = function (subscriberId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetSubscriberForDevelopmentEventsV0';
                                // verify required parameter 'subscriberId' is not null or undefined
                                if (subscriberId == null) {
                                    throw new Error("Required parameter subscriberId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('subscriberId', subscriberId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v0/developmentEvents/subscribers/{subscriberId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Successful operation.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Returns information about specified subscriber.
             * @param {string} subscriberId Unique identifier of the subscriber.
             */
            SkillManagementServiceClient.prototype.getSubscriberForDevelopmentEventsV0 = function (subscriberId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetSubscriberForDevelopmentEventsV0(subscriberId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Updates the properties of a subscriber.
             * @param {string} subscriberId Unique identifier of the subscriber.
             * @param {v0.developmentEvents.subscriber.UpdateSubscriberRequest} updateSubscriberRequest Defines the request body for updateSubscriber API.
             */
            SkillManagementServiceClient.prototype.callSetSubscriberForDevelopmentEventsV0 = function (subscriberId, updateSubscriberRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callSetSubscriberForDevelopmentEventsV0';
                                // verify required parameter 'subscriberId' is not null or undefined
                                if (subscriberId == null) {
                                    throw new Error("Required parameter subscriberId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'updateSubscriberRequest' is not null or undefined
                                if (updateSubscriberRequest == null) {
                                    throw new Error("Required parameter updateSubscriberRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('subscriberId', subscriberId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v0/developmentEvents/subscribers/{subscriberId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Success.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("PUT", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, updateSubscriberRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Updates the properties of a subscriber.
             * @param {string} subscriberId Unique identifier of the subscriber.
             * @param {v0.developmentEvents.subscriber.UpdateSubscriberRequest} updateSubscriberRequest Defines the request body for updateSubscriber API.
             */
            SkillManagementServiceClient.prototype.setSubscriberForDevelopmentEventsV0 = function (subscriberId, updateSubscriberRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callSetSubscriberForDevelopmentEventsV0(subscriberId, updateSubscriberRequest)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Lists all the subscriptions for a vendor/subscriber depending on the query parameter.
             * @param {string} vendorId The vendor ID.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {string} subscriberId Unique identifier of the subscriber. If this query parameter is provided, the list would be filtered by the owning subscriberId.
             */
            SkillManagementServiceClient.prototype.callListSubscriptionsForDevelopmentEventsV0 = function (vendorId, nextToken, maxResults, subscriberId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, vendorIdValues, nextTokenValues, maxResultsValues, subscriberIdValues, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callListSubscriptionsForDevelopmentEventsV0';
                                // verify required parameter 'vendorId' is not null or undefined
                                if (vendorId == null) {
                                    throw new Error("Required parameter vendorId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                vendorIdValues = Array.isArray(vendorId) ? vendorId : [vendorId];
                                vendorIdValues.forEach(function (val) { return queryParams.push({ key: 'vendorId', value: val }); });
                                if (nextToken != null) {
                                    nextTokenValues = Array.isArray(nextToken) ? nextToken : [nextToken];
                                    nextTokenValues.forEach(function (val) { return queryParams.push({ key: 'nextToken', value: val }); });
                                }
                                if (maxResults != null) {
                                    maxResultsValues = Array.isArray(maxResults) ? maxResults : [maxResults];
                                    maxResultsValues.forEach(function (val) { return queryParams.push({ key: 'maxResults', value: val.toString() }); });
                                }
                                if (subscriberId != null) {
                                    subscriberIdValues = Array.isArray(subscriberId) ? subscriberId : [subscriberId];
                                    subscriberIdValues.forEach(function (val) { return queryParams.push({ key: 'subscriberId', value: val }); });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v0/developmentEvents/subscriptions";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Successful operation.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Lists all the subscriptions for a vendor/subscriber depending on the query parameter.
             * @param {string} vendorId The vendor ID.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {string} subscriberId Unique identifier of the subscriber. If this query parameter is provided, the list would be filtered by the owning subscriberId.
             */
            SkillManagementServiceClient.prototype.listSubscriptionsForDevelopmentEventsV0 = function (vendorId, nextToken, maxResults, subscriberId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callListSubscriptionsForDevelopmentEventsV0(vendorId, nextToken, maxResults, subscriberId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Creates a new subscription for a subscriber. This needs to be authorized by the client/vendor who created the subscriber and the vendor who publishes the event.
             * @param {v0.developmentEvents.subscription.CreateSubscriptionRequest} createSubscriptionRequest Request body for createSubscription API.
             */
            SkillManagementServiceClient.prototype.callCreateSubscriptionForDevelopmentEventsV0 = function (createSubscriptionRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callCreateSubscriptionForDevelopmentEventsV0';
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v0/developmentEvents/subscriptions";
                                errorDefinitions = new Map();
                                errorDefinitions.set(201, "Created; Returns a URL to retrieve the subscription in &#39;Location&#39; header.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, createSubscriptionRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Creates a new subscription for a subscriber. This needs to be authorized by the client/vendor who created the subscriber and the vendor who publishes the event.
             * @param {v0.developmentEvents.subscription.CreateSubscriptionRequest} createSubscriptionRequest Request body for createSubscription API.
             */
            SkillManagementServiceClient.prototype.createSubscriptionForDevelopmentEventsV0 = function (createSubscriptionRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callCreateSubscriptionForDevelopmentEventsV0(createSubscriptionRequest)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Deletes a particular subscription. Both, the vendor who created the subscriber and the vendor who publishes the event can delete this resource with appropriate authorization.
             * @param {string} subscriptionId Unique identifier of the subscription.
             */
            SkillManagementServiceClient.prototype.callDeleteSubscriptionForDevelopmentEventsV0 = function (subscriptionId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callDeleteSubscriptionForDevelopmentEventsV0';
                                // verify required parameter 'subscriptionId' is not null or undefined
                                if (subscriptionId == null) {
                                    throw new Error("Required parameter subscriptionId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('subscriptionId', subscriptionId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v0/developmentEvents/subscriptions/{subscriptionId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Successful operation.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("DELETE", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Deletes a particular subscription. Both, the vendor who created the subscriber and the vendor who publishes the event can delete this resource with appropriate authorization.
             * @param {string} subscriptionId Unique identifier of the subscription.
             */
            SkillManagementServiceClient.prototype.deleteSubscriptionForDevelopmentEventsV0 = function (subscriptionId) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callDeleteSubscriptionForDevelopmentEventsV0(subscriptionId)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Returns information about a particular subscription. Both, the vendor who created the subscriber and the vendor who publishes the event can retrieve this resource with appropriate authorization.
             * @param {string} subscriptionId Unique identifier of the subscription.
             */
            SkillManagementServiceClient.prototype.callGetSubscriptionForDevelopmentEventsV0 = function (subscriptionId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetSubscriptionForDevelopmentEventsV0';
                                // verify required parameter 'subscriptionId' is not null or undefined
                                if (subscriptionId == null) {
                                    throw new Error("Required parameter subscriptionId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('subscriptionId', subscriptionId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v0/developmentEvents/subscriptions/{subscriptionId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Successful operation.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Returns information about a particular subscription. Both, the vendor who created the subscriber and the vendor who publishes the event can retrieve this resource with appropriate authorization.
             * @param {string} subscriptionId Unique identifier of the subscription.
             */
            SkillManagementServiceClient.prototype.getSubscriptionForDevelopmentEventsV0 = function (subscriptionId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetSubscriptionForDevelopmentEventsV0(subscriptionId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Updates the mutable properties of a subscription. This needs to be authorized by the client/vendor who created the subscriber and the vendor who publishes the event. The subscriberId cannot be updated.
             * @param {string} subscriptionId Unique identifier of the subscription.
             * @param {v0.developmentEvents.subscription.UpdateSubscriptionRequest} updateSubscriptionRequest Request body for updateSubscription API.
             */
            SkillManagementServiceClient.prototype.callSetSubscriptionForDevelopmentEventsV0 = function (subscriptionId, updateSubscriptionRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callSetSubscriptionForDevelopmentEventsV0';
                                // verify required parameter 'subscriptionId' is not null or undefined
                                if (subscriptionId == null) {
                                    throw new Error("Required parameter subscriptionId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('subscriptionId', subscriptionId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v0/developmentEvents/subscriptions/{subscriptionId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "No content.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("PUT", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, updateSubscriptionRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Updates the mutable properties of a subscription. This needs to be authorized by the client/vendor who created the subscriber and the vendor who publishes the event. The subscriberId cannot be updated.
             * @param {string} subscriptionId Unique identifier of the subscription.
             * @param {v0.developmentEvents.subscription.UpdateSubscriptionRequest} updateSubscriptionRequest Request body for updateSubscription API.
             */
            SkillManagementServiceClient.prototype.setSubscriptionForDevelopmentEventsV0 = function (subscriptionId, updateSubscriptionRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callSetSubscriptionForDevelopmentEventsV0(subscriptionId, updateSubscriptionRequest)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Associate skill with catalog.
             * @param {string} skillId The skill ID.
             * @param {string} catalogId Provides a unique identifier of the catalog.
             */
            SkillManagementServiceClient.prototype.callAssociateCatalogWithSkillV0 = function (skillId, catalogId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callAssociateCatalogWithSkillV0';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'catalogId' is not null or undefined
                                if (catalogId == null) {
                                    throw new Error("Required parameter catalogId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('catalogId', catalogId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v0/skills/{skillId}/catalogs/{catalogId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(201, "Successful operation.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("PUT", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Associate skill with catalog.
             * @param {string} skillId The skill ID.
             * @param {string} catalogId Provides a unique identifier of the catalog.
             */
            SkillManagementServiceClient.prototype.associateCatalogWithSkillV0 = function (skillId, catalogId) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callAssociateCatalogWithSkillV0(skillId, catalogId)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Lists all the catalogs associated with a skill.
             * @param {string} skillId The skill ID.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults
             */
            SkillManagementServiceClient.prototype.callListCatalogsForSkillV0 = function (skillId, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, nextTokenValues, maxResultsValues, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callListCatalogsForSkillV0';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (nextToken != null) {
                                    nextTokenValues = Array.isArray(nextToken) ? nextToken : [nextToken];
                                    nextTokenValues.forEach(function (val) { return queryParams.push({ key: 'nextToken', value: val }); });
                                }
                                if (maxResults != null) {
                                    maxResultsValues = Array.isArray(maxResults) ? maxResults : [maxResults];
                                    maxResultsValues.forEach(function (val) { return queryParams.push({ key: 'maxResults', value: val.toString() }); });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v0/skills/{skillId}/catalogs";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Successful operation.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Lists all the catalogs associated with a skill.
             * @param {string} skillId The skill ID.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults
             */
            SkillManagementServiceClient.prototype.listCatalogsForSkillV0 = function (skillId, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callListCatalogsForSkillV0(skillId, nextToken, maxResults)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Creates a new upload for a catalog and returns location to track the upload process.
             * @param {string} catalogId Provides a unique identifier of the catalog.
             * @param {v1.catalog.upload.CatalogUploadBase} catalogUploadRequestBody Provides the request body for create content upload
             */
            SkillManagementServiceClient.prototype.callCreateCatalogUploadV1 = function (catalogId, catalogUploadRequestBody) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callCreateCatalogUploadV1';
                                // verify required parameter 'catalogId' is not null or undefined
                                if (catalogId == null) {
                                    throw new Error("Required parameter catalogId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'catalogUploadRequestBody' is not null or undefined
                                if (catalogUploadRequestBody == null) {
                                    throw new Error("Required parameter catalogUploadRequestBody was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('catalogId', catalogId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/catalogs/{catalogId}/uploads";
                                errorDefinitions = new Map();
                                errorDefinitions.set(202, "Accepted");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId. ");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, catalogUploadRequestBody, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Creates a new upload for a catalog and returns location to track the upload process.
             * @param {string} catalogId Provides a unique identifier of the catalog.
             * @param {v1.catalog.upload.CatalogUploadBase} catalogUploadRequestBody Provides the request body for create content upload
             */
            SkillManagementServiceClient.prototype.createCatalogUploadV1 = function (catalogId, catalogUploadRequestBody) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callCreateCatalogUploadV1(catalogId, catalogUploadRequestBody)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Gets detailed information about an upload which was created for a specific catalog. Includes the upload's ingestion steps and a url for downloading the file.
             * @param {string} catalogId Provides a unique identifier of the catalog.
             * @param {string} uploadId Unique identifier of the upload.
             */
            SkillManagementServiceClient.prototype.callGetContentUploadByIdV1 = function (catalogId, uploadId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetContentUploadByIdV1';
                                // verify required parameter 'catalogId' is not null or undefined
                                if (catalogId == null) {
                                    throw new Error("Required parameter catalogId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'uploadId' is not null or undefined
                                if (uploadId == null) {
                                    throw new Error("Required parameter uploadId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('catalogId', catalogId);
                                pathParams.set('uploadId', uploadId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/catalogs/{catalogId}/uploads/{uploadId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Successful operation.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId. ");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Gets detailed information about an upload which was created for a specific catalog. Includes the upload's ingestion steps and a url for downloading the file.
             * @param {string} catalogId Provides a unique identifier of the catalog.
             * @param {string} uploadId Unique identifier of the upload.
             */
            SkillManagementServiceClient.prototype.getContentUploadByIdV1 = function (catalogId, uploadId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetContentUploadByIdV1(catalogId, uploadId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Generates preSigned urls to upload data
             * @param {string} catalogId Provides a unique identifier of the catalog.
             * @param {v1.catalog.CreateContentUploadUrlRequest} generateCatalogUploadUrlRequestBody Request body to generate catalog upload url
             */
            SkillManagementServiceClient.prototype.callGenerateCatalogUploadUrlV1 = function (catalogId, generateCatalogUploadUrlRequestBody) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGenerateCatalogUploadUrlV1';
                                // verify required parameter 'catalogId' is not null or undefined
                                if (catalogId == null) {
                                    throw new Error("Required parameter catalogId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'generateCatalogUploadUrlRequestBody' is not null or undefined
                                if (generateCatalogUploadUrlRequestBody == null) {
                                    throw new Error("Required parameter generateCatalogUploadUrlRequestBody was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('catalogId', catalogId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/catalogs/{catalogId}/urls";
                                errorDefinitions = new Map();
                                errorDefinitions.set(201, "Successful operation.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, generateCatalogUploadUrlRequestBody, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Generates preSigned urls to upload data
             * @param {string} catalogId Provides a unique identifier of the catalog.
             * @param {v1.catalog.CreateContentUploadUrlRequest} generateCatalogUploadUrlRequestBody Request body to generate catalog upload url
             */
            SkillManagementServiceClient.prototype.generateCatalogUploadUrlV1 = function (catalogId, generateCatalogUploadUrlRequestBody) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGenerateCatalogUploadUrlV1(catalogId, generateCatalogUploadUrlRequestBody)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * The SMAPI Audit Logs API provides customers with an audit history of all SMAPI calls made by a developer or developers with permissions on that account.
             * @param {v1.auditLogs.AuditLogsRequest} getAuditLogsRequest Request object encompassing vendorId, optional request filters and optional pagination context.
             */
            SkillManagementServiceClient.prototype.callQueryDevelopmentAuditLogsV1 = function (getAuditLogsRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callQueryDevelopmentAuditLogsV1';
                                // verify required parameter 'getAuditLogsRequest' is not null or undefined
                                if (getAuditLogsRequest == null) {
                                    throw new Error("Required parameter getAuditLogsRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/developmentAuditLogs/query";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns a list of audit logs for the given vendor.");
                                errorDefinitions.set(400, "Invalid request");
                                errorDefinitions.set(401, "Unauthorized");
                                errorDefinitions.set(403, "Forbidden");
                                errorDefinitions.set(404, "Not Found");
                                errorDefinitions.set(429, "Too Many Requests");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, getAuditLogsRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * The SMAPI Audit Logs API provides customers with an audit history of all SMAPI calls made by a developer or developers with permissions on that account.
             * @param {v1.auditLogs.AuditLogsRequest} getAuditLogsRequest Request object encompassing vendorId, optional request filters and optional pagination context.
             */
            SkillManagementServiceClient.prototype.queryDevelopmentAuditLogsV1 = function (getAuditLogsRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callQueryDevelopmentAuditLogsV1(getAuditLogsRequest)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Get the list of in-skill products for the vendor.
             * @param {string} vendorId The vendor ID.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {Array<string>} productId The list of in-skill product IDs that you wish to get the summary for. A maximum of 50 in-skill product IDs can be specified in a single listInSkillProducts call. Please note that this parameter must not be used with &#39;nextToken&#39; and/or &#39;maxResults&#39; parameter.
             * @param {string} stage Filter in-skill products by specified stage.
             * @param {string} type Type of in-skill product to filter on.
             * @param {string} referenceName Filter in-skill products by reference name.
             * @param {string} status Status of in-skill product.
             * @param {string} isAssociatedWithSkill Filter in-skill products by whether or not they are associated to a skill.
             */
            SkillManagementServiceClient.prototype.callGetIspListForVendorV1 = function (vendorId, nextToken, maxResults, productId, stage, type, referenceName, status, isAssociatedWithSkill) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, vendorIdValues, nextTokenValues, maxResultsValues, productIdValues, stageValues, typeValues, referenceNameValues, statusValues, isAssociatedWithSkillValues, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetIspListForVendorV1';
                                // verify required parameter 'vendorId' is not null or undefined
                                if (vendorId == null) {
                                    throw new Error("Required parameter vendorId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                vendorIdValues = Array.isArray(vendorId) ? vendorId : [vendorId];
                                vendorIdValues.forEach(function (val) { return queryParams.push({ key: 'vendorId', value: val }); });
                                if (nextToken != null) {
                                    nextTokenValues = Array.isArray(nextToken) ? nextToken : [nextToken];
                                    nextTokenValues.forEach(function (val) { return queryParams.push({ key: 'nextToken', value: val }); });
                                }
                                if (maxResults != null) {
                                    maxResultsValues = Array.isArray(maxResults) ? maxResults : [maxResults];
                                    maxResultsValues.forEach(function (val) { return queryParams.push({ key: 'maxResults', value: val.toString() }); });
                                }
                                if (productId != null) {
                                    productIdValues = Array.isArray(productId) ? productId : [productId];
                                    productIdValues.forEach(function (val) { return queryParams.push({ key: 'productId', value: val.toString() }); });
                                }
                                if (stage != null) {
                                    stageValues = Array.isArray(stage) ? stage : [stage];
                                    stageValues.forEach(function (val) { return queryParams.push({ key: 'stage', value: val }); });
                                }
                                if (type != null) {
                                    typeValues = Array.isArray(type) ? type : [type];
                                    typeValues.forEach(function (val) { return queryParams.push({ key: 'type', value: val }); });
                                }
                                if (referenceName != null) {
                                    referenceNameValues = Array.isArray(referenceName) ? referenceName : [referenceName];
                                    referenceNameValues.forEach(function (val) { return queryParams.push({ key: 'referenceName', value: val }); });
                                }
                                if (status != null) {
                                    statusValues = Array.isArray(status) ? status : [status];
                                    statusValues.forEach(function (val) { return queryParams.push({ key: 'status', value: val }); });
                                }
                                if (isAssociatedWithSkill != null) {
                                    isAssociatedWithSkillValues = Array.isArray(isAssociatedWithSkill) ? isAssociatedWithSkill : [isAssociatedWithSkill];
                                    isAssociatedWithSkillValues.forEach(function (val) { return queryParams.push({ key: 'isAssociatedWithSkill', value: val }); });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/inSkillProducts";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Response contains list of in-skill products for the specified vendor and stage.");
                                errorDefinitions.set(400, "Bad request. Returned when a required parameter is not present, badly formatted. ");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(429, "Too many requests received.");
                                errorDefinitions.set(500, "Internal Server Error");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Get the list of in-skill products for the vendor.
             * @param {string} vendorId The vendor ID.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {Array<string>} productId The list of in-skill product IDs that you wish to get the summary for. A maximum of 50 in-skill product IDs can be specified in a single listInSkillProducts call. Please note that this parameter must not be used with &#39;nextToken&#39; and/or &#39;maxResults&#39; parameter.
             * @param {string} stage Filter in-skill products by specified stage.
             * @param {string} type Type of in-skill product to filter on.
             * @param {string} referenceName Filter in-skill products by reference name.
             * @param {string} status Status of in-skill product.
             * @param {string} isAssociatedWithSkill Filter in-skill products by whether or not they are associated to a skill.
             */
            SkillManagementServiceClient.prototype.getIspListForVendorV1 = function (vendorId, nextToken, maxResults, productId, stage, type, referenceName, status, isAssociatedWithSkill) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetIspListForVendorV1(vendorId, nextToken, maxResults, productId, stage, type, referenceName, status, isAssociatedWithSkill)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Creates a new in-skill product for given vendorId.
             * @param {v1.isp.CreateInSkillProductRequest} createInSkillProductRequest defines the request body for createInSkillProduct API.
             */
            SkillManagementServiceClient.prototype.callCreateIspForVendorV1 = function (createInSkillProductRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callCreateIspForVendorV1';
                                // verify required parameter 'createInSkillProductRequest' is not null or undefined
                                if (createInSkillProductRequest == null) {
                                    throw new Error("Required parameter createInSkillProductRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/inSkillProducts";
                                errorDefinitions = new Map();
                                errorDefinitions.set(201, "Success.");
                                errorDefinitions.set(400, "Bad request. Returned when a required parameter is not present, badly formatted. ");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(429, "Too many requests received.");
                                errorDefinitions.set(500, "Internal Server Error");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, createInSkillProductRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Creates a new in-skill product for given vendorId.
             * @param {v1.isp.CreateInSkillProductRequest} createInSkillProductRequest defines the request body for createInSkillProduct API.
             */
            SkillManagementServiceClient.prototype.createIspForVendorV1 = function (createInSkillProductRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callCreateIspForVendorV1(createInSkillProductRequest)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Disassociates an in-skill product from a skill.
             * @param {string} productId The in-skill product ID.
             * @param {string} skillId The skill ID.
             */
            SkillManagementServiceClient.prototype.callDisassociateIspWithSkillV1 = function (productId, skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callDisassociateIspWithSkillV1';
                                // verify required parameter 'productId' is not null or undefined
                                if (productId == null) {
                                    throw new Error("Required parameter productId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('productId', productId);
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/inSkillProducts/{productId}/skills/{skillId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Success. No content.");
                                errorDefinitions.set(400, "Bad request. Returned when a required parameter is not present, badly formatted. ");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "Request is forbidden.");
                                errorDefinitions.set(404, "Requested resource not found.");
                                errorDefinitions.set(429, "Too many requests received.");
                                errorDefinitions.set(500, "Internal Server Error");
                                return [2 /*return*/, this.invoke("DELETE", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Disassociates an in-skill product from a skill.
             * @param {string} productId The in-skill product ID.
             * @param {string} skillId The skill ID.
             */
            SkillManagementServiceClient.prototype.disassociateIspWithSkillV1 = function (productId, skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callDisassociateIspWithSkillV1(productId, skillId)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Associates an in-skill product with a skill.
             * @param {string} productId The in-skill product ID.
             * @param {string} skillId The skill ID.
             */
            SkillManagementServiceClient.prototype.callAssociateIspWithSkillV1 = function (productId, skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callAssociateIspWithSkillV1';
                                // verify required parameter 'productId' is not null or undefined
                                if (productId == null) {
                                    throw new Error("Required parameter productId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('productId', productId);
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/inSkillProducts/{productId}/skills/{skillId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Success. No content.");
                                errorDefinitions.set(400, "Bad request. Returned when a required parameter is not present, badly formatted. ");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "Request is forbidden.");
                                errorDefinitions.set(404, "Requested resource not found.");
                                errorDefinitions.set(429, "Too many requests received.");
                                errorDefinitions.set(500, "Internal Server Error");
                                return [2 /*return*/, this.invoke("PUT", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Associates an in-skill product with a skill.
             * @param {string} productId The in-skill product ID.
             * @param {string} skillId The skill ID.
             */
            SkillManagementServiceClient.prototype.associateIspWithSkillV1 = function (productId, skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callAssociateIspWithSkillV1(productId, skillId)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Deletes the in-skill product for given productId. Only development stage supported. Live in-skill products or in-skill products associated with a skill cannot be deleted by this API.
             * @param {string} productId The in-skill product ID.
             * @param {string} stage Stage for skill.
             * @param {string} ifMatch Request header that specified an entity tag. The server will update the resource only if the eTag matches with the resource&#39;s current eTag.
             */
            SkillManagementServiceClient.prototype.callDeleteIspForProductV1 = function (productId, stage, ifMatch) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callDeleteIspForProductV1';
                                // verify required parameter 'productId' is not null or undefined
                                if (productId == null) {
                                    throw new Error("Required parameter productId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (ifMatch != null) {
                                    headerParams.push({ key: 'If-Match', value: ifMatch });
                                }
                                pathParams = new Map();
                                pathParams.set('productId', productId);
                                pathParams.set('stage', stage);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/inSkillProducts/{productId}/stages/{stage}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Success. No content.");
                                errorDefinitions.set(400, "Bad request. Returned when a required parameter is not present, badly formatted. ");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "Request is forbidden.");
                                errorDefinitions.set(404, "Requested resource not found.");
                                errorDefinitions.set(412, "Precondition failed.");
                                errorDefinitions.set(429, "Too many requests received.");
                                errorDefinitions.set(500, "Internal Server Error");
                                return [2 /*return*/, this.invoke("DELETE", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Deletes the in-skill product for given productId. Only development stage supported. Live in-skill products or in-skill products associated with a skill cannot be deleted by this API.
             * @param {string} productId The in-skill product ID.
             * @param {string} stage Stage for skill.
             * @param {string} ifMatch Request header that specified an entity tag. The server will update the resource only if the eTag matches with the resource&#39;s current eTag.
             */
            SkillManagementServiceClient.prototype.deleteIspForProductV1 = function (productId, stage, ifMatch) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callDeleteIspForProductV1(productId, stage, ifMatch)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Resets the entitlement(s) of the Product for the current user.
             * @param {string} productId The in-skill product ID.
             * @param {string} stage Stage for skill.
             */
            SkillManagementServiceClient.prototype.callResetEntitlementForProductV1 = function (productId, stage) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callResetEntitlementForProductV1';
                                // verify required parameter 'productId' is not null or undefined
                                if (productId == null) {
                                    throw new Error("Required parameter productId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('productId', productId);
                                pathParams.set('stage', stage);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/inSkillProducts/{productId}/stages/{stage}/entitlement";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Success. No content.");
                                errorDefinitions.set(400, "Bad request. Returned when a required parameter is not present, badly formatted. ");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "Request is forbidden.");
                                errorDefinitions.set(404, "Requested resource not found.");
                                errorDefinitions.set(412, "Precondition failed.");
                                errorDefinitions.set(429, "Too many requests received.");
                                errorDefinitions.set(500, "Internal Server Error");
                                return [2 /*return*/, this.invoke("DELETE", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Resets the entitlement(s) of the Product for the current user.
             * @param {string} productId The in-skill product ID.
             * @param {string} stage Stage for skill.
             */
            SkillManagementServiceClient.prototype.resetEntitlementForProductV1 = function (productId, stage) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callResetEntitlementForProductV1(productId, stage)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Returns the in-skill product definition for given productId.
             * @param {string} productId The in-skill product ID.
             * @param {string} stage Stage for skill.
             */
            SkillManagementServiceClient.prototype.callGetIspDefinitionV1 = function (productId, stage) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetIspDefinitionV1';
                                // verify required parameter 'productId' is not null or undefined
                                if (productId == null) {
                                    throw new Error("Required parameter productId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('productId', productId);
                                pathParams.set('stage', stage);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/inSkillProducts/{productId}/stages/{stage}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Response contains the latest version of an in-skill product for the specified stage.");
                                errorDefinitions.set(400, "Bad request. Returned when a required parameter is not present, badly formatted. ");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "Requested resource not found.");
                                errorDefinitions.set(429, "Too many requests received.");
                                errorDefinitions.set(500, "Internal Server Error");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Returns the in-skill product definition for given productId.
             * @param {string} productId The in-skill product ID.
             * @param {string} stage Stage for skill.
             */
            SkillManagementServiceClient.prototype.getIspDefinitionV1 = function (productId, stage) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetIspDefinitionV1(productId, stage)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Updates in-skill product definition for given productId. Only development stage supported.
             * @param {string} productId The in-skill product ID.
             * @param {string} stage Stage for skill.
             * @param {v1.isp.UpdateInSkillProductRequest} updateInSkillProductRequest defines the request body for updateInSkillProduct API.
             * @param {string} ifMatch Request header that specified an entity tag. The server will update the resource only if the eTag matches with the resource&#39;s current eTag.
             */
            SkillManagementServiceClient.prototype.callUpdateIspForProductV1 = function (productId, stage, updateInSkillProductRequest, ifMatch) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callUpdateIspForProductV1';
                                // verify required parameter 'productId' is not null or undefined
                                if (productId == null) {
                                    throw new Error("Required parameter productId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'updateInSkillProductRequest' is not null or undefined
                                if (updateInSkillProductRequest == null) {
                                    throw new Error("Required parameter updateInSkillProductRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (ifMatch != null) {
                                    headerParams.push({ key: 'If-Match', value: ifMatch });
                                }
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('productId', productId);
                                pathParams.set('stage', stage);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/inSkillProducts/{productId}/stages/{stage}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Success.");
                                errorDefinitions.set(400, "Bad request. Returned when a required parameter is not present, badly formatted. ");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "Request is forbidden.");
                                errorDefinitions.set(404, "Requested resource not found.");
                                errorDefinitions.set(412, "Precondition failed.");
                                errorDefinitions.set(429, "Too many requests received.");
                                errorDefinitions.set(500, "Internal Server Error");
                                return [2 /*return*/, this.invoke("PUT", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, updateInSkillProductRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Updates in-skill product definition for given productId. Only development stage supported.
             * @param {string} productId The in-skill product ID.
             * @param {string} stage Stage for skill.
             * @param {v1.isp.UpdateInSkillProductRequest} updateInSkillProductRequest defines the request body for updateInSkillProduct API.
             * @param {string} ifMatch Request header that specified an entity tag. The server will update the resource only if the eTag matches with the resource&#39;s current eTag.
             */
            SkillManagementServiceClient.prototype.updateIspForProductV1 = function (productId, stage, updateInSkillProductRequest, ifMatch) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callUpdateIspForProductV1(productId, stage, updateInSkillProductRequest, ifMatch)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Get the associated skills for the in-skill product.
             * @param {string} productId The in-skill product ID.
             * @param {string} stage Stage for skill.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             */
            SkillManagementServiceClient.prototype.callGetIspAssociatedSkillsV1 = function (productId, stage, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, nextTokenValues, maxResultsValues, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetIspAssociatedSkillsV1';
                                // verify required parameter 'productId' is not null or undefined
                                if (productId == null) {
                                    throw new Error("Required parameter productId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (nextToken != null) {
                                    nextTokenValues = Array.isArray(nextToken) ? nextToken : [nextToken];
                                    nextTokenValues.forEach(function (val) { return queryParams.push({ key: 'nextToken', value: val }); });
                                }
                                if (maxResults != null) {
                                    maxResultsValues = Array.isArray(maxResults) ? maxResults : [maxResults];
                                    maxResultsValues.forEach(function (val) { return queryParams.push({ key: 'maxResults', value: val.toString() }); });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('productId', productId);
                                pathParams.set('stage', stage);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/inSkillProducts/{productId}/stages/{stage}/skills";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns skills associated with the in-skill product.");
                                errorDefinitions.set(400, "Bad request. Returned when a required parameter is not present, badly formatted. ");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "Requested resource not found.");
                                errorDefinitions.set(429, "Too many requests received.");
                                errorDefinitions.set(500, "Internal Server Error");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Get the associated skills for the in-skill product.
             * @param {string} productId The in-skill product ID.
             * @param {string} stage Stage for skill.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             */
            SkillManagementServiceClient.prototype.getIspAssociatedSkillsV1 = function (productId, stage, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetIspAssociatedSkillsV1(productId, stage, nextToken, maxResults)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Get the summary information for an in-skill product.
             * @param {string} productId The in-skill product ID.
             * @param {string} stage Stage for skill.
             */
            SkillManagementServiceClient.prototype.callGetIspSummaryV1 = function (productId, stage) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetIspSummaryV1';
                                // verify required parameter 'productId' is not null or undefined
                                if (productId == null) {
                                    throw new Error("Required parameter productId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('productId', productId);
                                pathParams.set('stage', stage);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/inSkillProducts/{productId}/stages/{stage}/summary";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns current in-skill product summary for productId.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "Requested resource not found.");
                                errorDefinitions.set(429, "Too many requests received.");
                                errorDefinitions.set(500, "Internal Server Error");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Get the summary information for an in-skill product.
             * @param {string} productId The in-skill product ID.
             * @param {string} stage Stage for skill.
             */
            SkillManagementServiceClient.prototype.getIspSummaryV1 = function (productId, stage) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetIspSummaryV1(productId, stage)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Delete the catalog.
             * @param {string} catalogId Provides a unique identifier of the catalog.
             */
            SkillManagementServiceClient.prototype.callDeleteInteractionModelCatalogV1 = function (catalogId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callDeleteInteractionModelCatalogV1';
                                // verify required parameter 'catalogId' is not null or undefined
                                if (catalogId == null) {
                                    throw new Error("Required parameter catalogId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('catalogId', catalogId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/api/custom/interactionModel/catalogs/{catalogId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "No content; just confirm the catalog is deleted.");
                                errorDefinitions.set(400, "The catalog cannot be deleted from reasons due to in-use by other entities.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "There is no catalog defined for the catalogId.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("DELETE", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Delete the catalog.
             * @param {string} catalogId Provides a unique identifier of the catalog.
             */
            SkillManagementServiceClient.prototype.deleteInteractionModelCatalogV1 = function (catalogId) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callDeleteInteractionModelCatalogV1(catalogId)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * get the catalog definition
             * @param {string} catalogId Provides a unique identifier of the catalog.
             */
            SkillManagementServiceClient.prototype.callGetInteractionModelCatalogDefinitionV1 = function (catalogId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetInteractionModelCatalogDefinitionV1';
                                // verify required parameter 'catalogId' is not null or undefined
                                if (catalogId == null) {
                                    throw new Error("Required parameter catalogId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('catalogId', catalogId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/api/custom/interactionModel/catalogs/{catalogId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "the catalog definition");
                                errorDefinitions.set(400, "The catalog cannot be retrieved due to errors listed.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "There is no catalog defined for the catalogId.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * get the catalog definition
             * @param {string} catalogId Provides a unique identifier of the catalog.
             */
            SkillManagementServiceClient.prototype.getInteractionModelCatalogDefinitionV1 = function (catalogId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetInteractionModelCatalogDefinitionV1(catalogId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * update description and vendorGuidance string for certain version of a catalog.
             * @param {string} catalogId Provides a unique identifier of the catalog.
             * @param {v1.skill.interactionModel.catalog.UpdateRequest} updateRequest
             */
            SkillManagementServiceClient.prototype.callUpdateInteractionModelCatalogV1 = function (catalogId, updateRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callUpdateInteractionModelCatalogV1';
                                // verify required parameter 'catalogId' is not null or undefined
                                if (catalogId == null) {
                                    throw new Error("Required parameter catalogId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'updateRequest' is not null or undefined
                                if (updateRequest == null) {
                                    throw new Error("Required parameter updateRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('catalogId', catalogId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/api/custom/interactionModel/catalogs/{catalogId}/update";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "No content, indicates the fields were successfully updated.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "There is no catalog defined for the catalogId.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, updateRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * update description and vendorGuidance string for certain version of a catalog.
             * @param {string} catalogId Provides a unique identifier of the catalog.
             * @param {v1.skill.interactionModel.catalog.UpdateRequest} updateRequest
             */
            SkillManagementServiceClient.prototype.updateInteractionModelCatalogV1 = function (catalogId, updateRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callUpdateInteractionModelCatalogV1(catalogId, updateRequest)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Get the status of catalog resource and its sub-resources for a given catalogId.
             * @param {string} catalogId Provides a unique identifier of the catalog.
             * @param {string} updateRequestId The identifier for slotType version creation process
             */
            SkillManagementServiceClient.prototype.callGetInteractionModelCatalogUpdateStatusV1 = function (catalogId, updateRequestId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetInteractionModelCatalogUpdateStatusV1';
                                // verify required parameter 'catalogId' is not null or undefined
                                if (catalogId == null) {
                                    throw new Error("Required parameter catalogId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'updateRequestId' is not null or undefined
                                if (updateRequestId == null) {
                                    throw new Error("Required parameter updateRequestId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('catalogId', catalogId);
                                pathParams.set('updateRequestId', updateRequestId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/api/custom/interactionModel/catalogs/{catalogId}/updateRequest/{updateRequestId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns the build status and error codes for the given catalogId");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "There is no catalog defined for the catalogId.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Get the status of catalog resource and its sub-resources for a given catalogId.
             * @param {string} catalogId Provides a unique identifier of the catalog.
             * @param {string} updateRequestId The identifier for slotType version creation process
             */
            SkillManagementServiceClient.prototype.getInteractionModelCatalogUpdateStatusV1 = function (catalogId, updateRequestId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetInteractionModelCatalogUpdateStatusV1(catalogId, updateRequestId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * List all the historical versions of the given catalogId.
             * @param {string} catalogId Provides a unique identifier of the catalog.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {string} sortDirection Sets the sorting direction of the result items. When set to &#39;asc&#39; these items are returned in ascending order of sortField value and when set to &#39;desc&#39; these items are returned in descending order of sortField value.
             * @param {string} sortField Sets the field on which the sorting would be applied.
             */
            SkillManagementServiceClient.prototype.callListInteractionModelCatalogVersionsV1 = function (catalogId, maxResults, nextToken, sortDirection, sortField) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, maxResultsValues, nextTokenValues, sortDirectionValues, sortFieldValues, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callListInteractionModelCatalogVersionsV1';
                                // verify required parameter 'catalogId' is not null or undefined
                                if (catalogId == null) {
                                    throw new Error("Required parameter catalogId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (maxResults != null) {
                                    maxResultsValues = Array.isArray(maxResults) ? maxResults : [maxResults];
                                    maxResultsValues.forEach(function (val) { return queryParams.push({ key: 'maxResults', value: val.toString() }); });
                                }
                                if (nextToken != null) {
                                    nextTokenValues = Array.isArray(nextToken) ? nextToken : [nextToken];
                                    nextTokenValues.forEach(function (val) { return queryParams.push({ key: 'nextToken', value: val }); });
                                }
                                if (sortDirection != null) {
                                    sortDirectionValues = Array.isArray(sortDirection) ? sortDirection : [sortDirection];
                                    sortDirectionValues.forEach(function (val) { return queryParams.push({ key: 'sortDirection', value: val }); });
                                }
                                if (sortField != null) {
                                    sortFieldValues = Array.isArray(sortField) ? sortField : [sortField];
                                    sortFieldValues.forEach(function (val) { return queryParams.push({ key: 'sortField', value: val }); });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('catalogId', catalogId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/api/custom/interactionModel/catalogs/{catalogId}/versions";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns list of catalogs for the vendor.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error e.g. the catalog definition is invalid.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The specified catalog does not exist.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * List all the historical versions of the given catalogId.
             * @param {string} catalogId Provides a unique identifier of the catalog.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {string} sortDirection Sets the sorting direction of the result items. When set to &#39;asc&#39; these items are returned in ascending order of sortField value and when set to &#39;desc&#39; these items are returned in descending order of sortField value.
             * @param {string} sortField Sets the field on which the sorting would be applied.
             */
            SkillManagementServiceClient.prototype.listInteractionModelCatalogVersionsV1 = function (catalogId, maxResults, nextToken, sortDirection, sortField) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callListInteractionModelCatalogVersionsV1(catalogId, maxResults, nextToken, sortDirection, sortField)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Create a new version of catalog entity for the given catalogId.
             * @param {string} catalogId Provides a unique identifier of the catalog.
             * @param {v1.skill.interactionModel.version.VersionData} catalog
             */
            SkillManagementServiceClient.prototype.callCreateInteractionModelCatalogVersionV1 = function (catalogId, catalog) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callCreateInteractionModelCatalogVersionV1';
                                // verify required parameter 'catalogId' is not null or undefined
                                if (catalogId == null) {
                                    throw new Error("Required parameter catalogId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'catalog' is not null or undefined
                                if (catalog == null) {
                                    throw new Error("Required parameter catalog was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('catalogId', catalogId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/api/custom/interactionModel/catalogs/{catalogId}/versions";
                                errorDefinitions = new Map();
                                errorDefinitions.set(202, "Returns update status location link on success.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error e.g. the catalog definition is invalid.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The specified catalog does not exist.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, catalog, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Create a new version of catalog entity for the given catalogId.
             * @param {string} catalogId Provides a unique identifier of the catalog.
             * @param {v1.skill.interactionModel.version.VersionData} catalog
             */
            SkillManagementServiceClient.prototype.createInteractionModelCatalogVersionV1 = function (catalogId, catalog) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callCreateInteractionModelCatalogVersionV1(catalogId, catalog)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Delete catalog version.
             * @param {string} catalogId Provides a unique identifier of the catalog.
             * @param {string} version Version for interaction model.
             */
            SkillManagementServiceClient.prototype.callDeleteInteractionModelCatalogVersionV1 = function (catalogId, version) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callDeleteInteractionModelCatalogVersionV1';
                                // verify required parameter 'catalogId' is not null or undefined
                                if (catalogId == null) {
                                    throw new Error("Required parameter catalogId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'version' is not null or undefined
                                if (version == null) {
                                    throw new Error("Required parameter version was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('catalogId', catalogId);
                                pathParams.set('version', version);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/api/custom/interactionModel/catalogs/{catalogId}/versions/{version}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "No Content; Confirms that version is successfully deleted.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "There is no catalog version for this catalogId.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("DELETE", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Delete catalog version.
             * @param {string} catalogId Provides a unique identifier of the catalog.
             * @param {string} version Version for interaction model.
             */
            SkillManagementServiceClient.prototype.deleteInteractionModelCatalogVersionV1 = function (catalogId, version) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callDeleteInteractionModelCatalogVersionV1(catalogId, version)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Get catalog version data of given catalog version.
             * @param {string} catalogId Provides a unique identifier of the catalog.
             * @param {string} version Version for interaction model.
             */
            SkillManagementServiceClient.prototype.callGetInteractionModelCatalogVersionV1 = function (catalogId, version) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetInteractionModelCatalogVersionV1';
                                // verify required parameter 'catalogId' is not null or undefined
                                if (catalogId == null) {
                                    throw new Error("Required parameter catalogId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'version' is not null or undefined
                                if (version == null) {
                                    throw new Error("Required parameter version was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('catalogId', catalogId);
                                pathParams.set('version', version);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/api/custom/interactionModel/catalogs/{catalogId}/versions/{version}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns the catalog version metadata for the given catalogId and version.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "There is no catalog defined for the catalogId.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Get catalog version data of given catalog version.
             * @param {string} catalogId Provides a unique identifier of the catalog.
             * @param {string} version Version for interaction model.
             */
            SkillManagementServiceClient.prototype.getInteractionModelCatalogVersionV1 = function (catalogId, version) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetInteractionModelCatalogVersionV1(catalogId, version)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Update description and vendorGuidance string for certain version of a catalog.
             * @param {string} catalogId Provides a unique identifier of the catalog.
             * @param {string} version Version for interaction model.
             * @param {v1.skill.interactionModel.version.CatalogUpdate} catalogUpdate
             */
            SkillManagementServiceClient.prototype.callUpdateInteractionModelCatalogVersionV1 = function (catalogId, version, catalogUpdate) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callUpdateInteractionModelCatalogVersionV1';
                                // verify required parameter 'catalogId' is not null or undefined
                                if (catalogId == null) {
                                    throw new Error("Required parameter catalogId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'version' is not null or undefined
                                if (version == null) {
                                    throw new Error("Required parameter version was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('catalogId', catalogId);
                                pathParams.set('version', version);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/api/custom/interactionModel/catalogs/{catalogId}/versions/{version}/update";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "No Content; Confirms that version is successfully updated.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "There is no catalog defined for the catalogId");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, catalogUpdate, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Update description and vendorGuidance string for certain version of a catalog.
             * @param {string} catalogId Provides a unique identifier of the catalog.
             * @param {string} version Version for interaction model.
             * @param {v1.skill.interactionModel.version.CatalogUpdate} catalogUpdate
             */
            SkillManagementServiceClient.prototype.updateInteractionModelCatalogVersionV1 = function (catalogId, version, catalogUpdate) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callUpdateInteractionModelCatalogVersionV1(catalogId, version, catalogUpdate)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Get catalog values from the given catalogId & version.
             * @param {string} catalogId Provides a unique identifier of the catalog.
             * @param {string} version Version for interaction model.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             */
            SkillManagementServiceClient.prototype.callGetInteractionModelCatalogValuesV1 = function (catalogId, version, maxResults, nextToken) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, maxResultsValues, nextTokenValues, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetInteractionModelCatalogValuesV1';
                                // verify required parameter 'catalogId' is not null or undefined
                                if (catalogId == null) {
                                    throw new Error("Required parameter catalogId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'version' is not null or undefined
                                if (version == null) {
                                    throw new Error("Required parameter version was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (maxResults != null) {
                                    maxResultsValues = Array.isArray(maxResults) ? maxResults : [maxResults];
                                    maxResultsValues.forEach(function (val) { return queryParams.push({ key: 'maxResults', value: val.toString() }); });
                                }
                                if (nextToken != null) {
                                    nextTokenValues = Array.isArray(nextToken) ? nextToken : [nextToken];
                                    nextTokenValues.forEach(function (val) { return queryParams.push({ key: 'nextToken', value: val }); });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('catalogId', catalogId);
                                pathParams.set('version', version);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/api/custom/interactionModel/catalogs/{catalogId}/versions/{version}/values";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns list of catalog values for the given catalogId and version.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "There is no catalog defined for the catalogId");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Get catalog values from the given catalogId & version.
             * @param {string} catalogId Provides a unique identifier of the catalog.
             * @param {string} version Version for interaction model.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             */
            SkillManagementServiceClient.prototype.getInteractionModelCatalogValuesV1 = function (catalogId, version, maxResults, nextToken) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetInteractionModelCatalogValuesV1(catalogId, version, maxResults, nextToken)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * List all catalogs for the vendor.
             * @param {string} vendorId The vendor ID.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {string} sortDirection Sets the sorting direction of the result items. When set to &#39;asc&#39; these items are returned in ascending order of sortField value and when set to &#39;desc&#39; these items are returned in descending order of sortField value.
             */
            SkillManagementServiceClient.prototype.callListInteractionModelCatalogsV1 = function (vendorId, maxResults, nextToken, sortDirection) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, vendorIdValues, maxResultsValues, nextTokenValues, sortDirectionValues, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callListInteractionModelCatalogsV1';
                                // verify required parameter 'vendorId' is not null or undefined
                                if (vendorId == null) {
                                    throw new Error("Required parameter vendorId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                vendorIdValues = Array.isArray(vendorId) ? vendorId : [vendorId];
                                vendorIdValues.forEach(function (val) { return queryParams.push({ key: 'vendorId', value: val }); });
                                if (maxResults != null) {
                                    maxResultsValues = Array.isArray(maxResults) ? maxResults : [maxResults];
                                    maxResultsValues.forEach(function (val) { return queryParams.push({ key: 'maxResults', value: val.toString() }); });
                                }
                                if (nextToken != null) {
                                    nextTokenValues = Array.isArray(nextToken) ? nextToken : [nextToken];
                                    nextTokenValues.forEach(function (val) { return queryParams.push({ key: 'nextToken', value: val }); });
                                }
                                if (sortDirection != null) {
                                    sortDirectionValues = Array.isArray(sortDirection) ? sortDirection : [sortDirection];
                                    sortDirectionValues.forEach(function (val) { return queryParams.push({ key: 'sortDirection', value: val }); });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/api/custom/interactionModel/catalogs";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns list of catalogs for the vendor.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "There is no catalog defined for the catalogId.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * List all catalogs for the vendor.
             * @param {string} vendorId The vendor ID.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {string} sortDirection Sets the sorting direction of the result items. When set to &#39;asc&#39; these items are returned in ascending order of sortField value and when set to &#39;desc&#39; these items are returned in descending order of sortField value.
             */
            SkillManagementServiceClient.prototype.listInteractionModelCatalogsV1 = function (vendorId, maxResults, nextToken, sortDirection) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callListInteractionModelCatalogsV1(vendorId, maxResults, nextToken, sortDirection)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Create a new version of catalog within the given catalogId.
             * @param {v1.skill.interactionModel.catalog.DefinitionData} catalog
             */
            SkillManagementServiceClient.prototype.callCreateInteractionModelCatalogV1 = function (catalog) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callCreateInteractionModelCatalogV1';
                                // verify required parameter 'catalog' is not null or undefined
                                if (catalog == null) {
                                    throw new Error("Required parameter catalog was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/api/custom/interactionModel/catalogs";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns the generated catalogId.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error e.g. the catalog definition is invalid.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(412, "Precondition failed.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, catalog, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Create a new version of catalog within the given catalogId.
             * @param {v1.skill.interactionModel.catalog.DefinitionData} catalog
             */
            SkillManagementServiceClient.prototype.createInteractionModelCatalogV1 = function (catalog) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callCreateInteractionModelCatalogV1(catalog)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Retrieve a list of jobs associated with the vendor.
             * @param {string} vendorId The vendor ID.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             */
            SkillManagementServiceClient.prototype.callListJobDefinitionsForInteractionModelV1 = function (vendorId, maxResults, nextToken) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, vendorIdValues, maxResultsValues, nextTokenValues, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callListJobDefinitionsForInteractionModelV1';
                                // verify required parameter 'vendorId' is not null or undefined
                                if (vendorId == null) {
                                    throw new Error("Required parameter vendorId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                vendorIdValues = Array.isArray(vendorId) ? vendorId : [vendorId];
                                vendorIdValues.forEach(function (val) { return queryParams.push({ key: 'vendorId', value: val }); });
                                if (maxResults != null) {
                                    maxResultsValues = Array.isArray(maxResults) ? maxResults : [maxResults];
                                    maxResultsValues.forEach(function (val) { return queryParams.push({ key: 'maxResults', value: val.toString() }); });
                                }
                                if (nextToken != null) {
                                    nextTokenValues = Array.isArray(nextToken) ? nextToken : [nextToken];
                                    nextTokenValues.forEach(function (val) { return queryParams.push({ key: 'nextToken', value: val }); });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/api/custom/interactionModel/jobs";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "List of all jobs associated with the vendor.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Retrieve a list of jobs associated with the vendor.
             * @param {string} vendorId The vendor ID.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             */
            SkillManagementServiceClient.prototype.listJobDefinitionsForInteractionModelV1 = function (vendorId, maxResults, nextToken) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callListJobDefinitionsForInteractionModelV1(vendorId, maxResults, nextToken)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Delete the job definition for a given jobId.
             * @param {string} jobId The identifier for dynamic jobs.
             */
            SkillManagementServiceClient.prototype.callDeleteJobDefinitionForInteractionModelV1 = function (jobId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callDeleteJobDefinitionForInteractionModelV1';
                                // verify required parameter 'jobId' is not null or undefined
                                if (jobId == null) {
                                    throw new Error("Required parameter jobId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('jobId', jobId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/api/custom/interactionModel/jobs/{jobId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "No content, confirms the resource is updated.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("DELETE", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Delete the job definition for a given jobId.
             * @param {string} jobId The identifier for dynamic jobs.
             */
            SkillManagementServiceClient.prototype.deleteJobDefinitionForInteractionModelV1 = function (jobId) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callDeleteJobDefinitionForInteractionModelV1(jobId)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Cancel the next execution for the given job.
             * @param {string} jobId The identifier for dynamic jobs.
             * @param {string} executionId The identifier for dynamic job executions. Currently only allowed for scheduled executions.
             */
            SkillManagementServiceClient.prototype.callCancelNextJobExecutionForInteractionModelV1 = function (jobId, executionId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callCancelNextJobExecutionForInteractionModelV1';
                                // verify required parameter 'jobId' is not null or undefined
                                if (jobId == null) {
                                    throw new Error("Required parameter jobId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'executionId' is not null or undefined
                                if (executionId == null) {
                                    throw new Error("Required parameter executionId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('jobId', jobId);
                                pathParams.set('executionId', executionId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/api/custom/interactionModel/jobs/{jobId}/executions/{executionId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "No Content; Confirms that the next execution is canceled.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("DELETE", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Cancel the next execution for the given job.
             * @param {string} jobId The identifier for dynamic jobs.
             * @param {string} executionId The identifier for dynamic job executions. Currently only allowed for scheduled executions.
             */
            SkillManagementServiceClient.prototype.cancelNextJobExecutionForInteractionModelV1 = function (jobId, executionId) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callCancelNextJobExecutionForInteractionModelV1(jobId, executionId)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * List the execution history associated with the job definition, with default sortField to be the executions' timestamp.
             * @param {string} jobId The identifier for dynamic jobs.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {string} sortDirection Sets the sorting direction of the result items. When set to &#39;asc&#39; these items are returned in ascending order of sortField value and when set to &#39;desc&#39; these items are returned in descending order of sortField value.
             */
            SkillManagementServiceClient.prototype.callListJobExecutionsForInteractionModelV1 = function (jobId, maxResults, nextToken, sortDirection) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, maxResultsValues, nextTokenValues, sortDirectionValues, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callListJobExecutionsForInteractionModelV1';
                                // verify required parameter 'jobId' is not null or undefined
                                if (jobId == null) {
                                    throw new Error("Required parameter jobId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (maxResults != null) {
                                    maxResultsValues = Array.isArray(maxResults) ? maxResults : [maxResults];
                                    maxResultsValues.forEach(function (val) { return queryParams.push({ key: 'maxResults', value: val.toString() }); });
                                }
                                if (nextToken != null) {
                                    nextTokenValues = Array.isArray(nextToken) ? nextToken : [nextToken];
                                    nextTokenValues.forEach(function (val) { return queryParams.push({ key: 'nextToken', value: val }); });
                                }
                                if (sortDirection != null) {
                                    sortDirectionValues = Array.isArray(sortDirection) ? sortDirection : [sortDirection];
                                    sortDirectionValues.forEach(function (val) { return queryParams.push({ key: 'sortDirection', value: val }); });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('jobId', jobId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/api/custom/interactionModel/jobs/{jobId}/executions";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Retrun list of executions associated with the job definition.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * List the execution history associated with the job definition, with default sortField to be the executions' timestamp.
             * @param {string} jobId The identifier for dynamic jobs.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {string} sortDirection Sets the sorting direction of the result items. When set to &#39;asc&#39; these items are returned in ascending order of sortField value and when set to &#39;desc&#39; these items are returned in descending order of sortField value.
             */
            SkillManagementServiceClient.prototype.listJobExecutionsForInteractionModelV1 = function (jobId, maxResults, nextToken, sortDirection) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callListJobExecutionsForInteractionModelV1(jobId, maxResults, nextToken, sortDirection)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Get the job definition for a given jobId.
             * @param {string} jobId The identifier for dynamic jobs.
             */
            SkillManagementServiceClient.prototype.callGetJobDefinitionForInteractionModelV1 = function (jobId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetJobDefinitionForInteractionModelV1';
                                // verify required parameter 'jobId' is not null or undefined
                                if (jobId == null) {
                                    throw new Error("Required parameter jobId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('jobId', jobId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/api/custom/interactionModel/jobs/{jobId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "The job definition for a given jobId.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Get the job definition for a given jobId.
             * @param {string} jobId The identifier for dynamic jobs.
             */
            SkillManagementServiceClient.prototype.getJobDefinitionForInteractionModelV1 = function (jobId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetJobDefinitionForInteractionModelV1(jobId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Update the JobStatus to Enable or Disable a job.
             * @param {string} jobId The identifier for dynamic jobs.
             * @param {v1.skill.interactionModel.jobs.UpdateJobStatusRequest} updateJobStatusRequest Request to update Job Definition status.
             */
            SkillManagementServiceClient.prototype.callSetJobStatusForInteractionModelV1 = function (jobId, updateJobStatusRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callSetJobStatusForInteractionModelV1';
                                // verify required parameter 'jobId' is not null or undefined
                                if (jobId == null) {
                                    throw new Error("Required parameter jobId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'updateJobStatusRequest' is not null or undefined
                                if (updateJobStatusRequest == null) {
                                    throw new Error("Required parameter updateJobStatusRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('jobId', jobId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/api/custom/interactionModel/jobs/{jobId}/status";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "No content; Confirms that the fields are updated.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("PUT", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, updateJobStatusRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Update the JobStatus to Enable or Disable a job.
             * @param {string} jobId The identifier for dynamic jobs.
             * @param {v1.skill.interactionModel.jobs.UpdateJobStatusRequest} updateJobStatusRequest Request to update Job Definition status.
             */
            SkillManagementServiceClient.prototype.setJobStatusForInteractionModelV1 = function (jobId, updateJobStatusRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callSetJobStatusForInteractionModelV1(jobId, updateJobStatusRequest)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Creates a new Job Definition from the Job Definition request provided. This can be either a CatalogAutoRefresh, which supports time-based configurations for catalogs, or a ReferencedResourceVersionUpdate, which is used for slotTypes and Interaction models to be automatically updated on the dynamic update of their referenced catalog.
             * @param {v1.skill.interactionModel.jobs.CreateJobDefinitionRequest} createJobDefinitionRequest Request to create a new Job Definition.
             */
            SkillManagementServiceClient.prototype.callCreateJobDefinitionForInteractionModelV1 = function (createJobDefinitionRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callCreateJobDefinitionForInteractionModelV1';
                                // verify required parameter 'createJobDefinitionRequest' is not null or undefined
                                if (createJobDefinitionRequest == null) {
                                    throw new Error("Required parameter createJobDefinitionRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/api/custom/interactionModel/jobs";
                                errorDefinitions = new Map();
                                errorDefinitions.set(201, "Returns the generated jobId.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, createJobDefinitionRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Creates a new Job Definition from the Job Definition request provided. This can be either a CatalogAutoRefresh, which supports time-based configurations for catalogs, or a ReferencedResourceVersionUpdate, which is used for slotTypes and Interaction models to be automatically updated on the dynamic update of their referenced catalog.
             * @param {v1.skill.interactionModel.jobs.CreateJobDefinitionRequest} createJobDefinitionRequest Request to create a new Job Definition.
             */
            SkillManagementServiceClient.prototype.createJobDefinitionForInteractionModelV1 = function (createJobDefinitionRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callCreateJobDefinitionForInteractionModelV1(createJobDefinitionRequest)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * List all slot types for the vendor.
             * @param {string} vendorId The vendor ID.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {string} sortDirection Sets the sorting direction of the result items. When set to &#39;asc&#39; these items are returned in ascending order of sortField value and when set to &#39;desc&#39; these items are returned in descending order of sortField value.
             */
            SkillManagementServiceClient.prototype.callListInteractionModelSlotTypesV1 = function (vendorId, maxResults, nextToken, sortDirection) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, vendorIdValues, maxResultsValues, nextTokenValues, sortDirectionValues, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callListInteractionModelSlotTypesV1';
                                // verify required parameter 'vendorId' is not null or undefined
                                if (vendorId == null) {
                                    throw new Error("Required parameter vendorId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                vendorIdValues = Array.isArray(vendorId) ? vendorId : [vendorId];
                                vendorIdValues.forEach(function (val) { return queryParams.push({ key: 'vendorId', value: val }); });
                                if (maxResults != null) {
                                    maxResultsValues = Array.isArray(maxResults) ? maxResults : [maxResults];
                                    maxResultsValues.forEach(function (val) { return queryParams.push({ key: 'maxResults', value: val.toString() }); });
                                }
                                if (nextToken != null) {
                                    nextTokenValues = Array.isArray(nextToken) ? nextToken : [nextToken];
                                    nextTokenValues.forEach(function (val) { return queryParams.push({ key: 'nextToken', value: val }); });
                                }
                                if (sortDirection != null) {
                                    sortDirectionValues = Array.isArray(sortDirection) ? sortDirection : [sortDirection];
                                    sortDirectionValues.forEach(function (val) { return queryParams.push({ key: 'sortDirection', value: val }); });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/api/custom/interactionModel/slotTypes";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns list of slot types for the vendor.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * List all slot types for the vendor.
             * @param {string} vendorId The vendor ID.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {string} sortDirection Sets the sorting direction of the result items. When set to &#39;asc&#39; these items are returned in ascending order of sortField value and when set to &#39;desc&#39; these items are returned in descending order of sortField value.
             */
            SkillManagementServiceClient.prototype.listInteractionModelSlotTypesV1 = function (vendorId, maxResults, nextToken, sortDirection) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callListInteractionModelSlotTypesV1(vendorId, maxResults, nextToken, sortDirection)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Create a new version of slot type within the given slotTypeId.
             * @param {v1.skill.interactionModel.type.DefinitionData} slotType
             */
            SkillManagementServiceClient.prototype.callCreateInteractionModelSlotTypeV1 = function (slotType) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callCreateInteractionModelSlotTypeV1';
                                // verify required parameter 'slotType' is not null or undefined
                                if (slotType == null) {
                                    throw new Error("Required parameter slotType was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/api/custom/interactionModel/slotTypes";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns the generated slotTypeId.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error e.g. the slot type definition is invalid.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, slotType, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Create a new version of slot type within the given slotTypeId.
             * @param {v1.skill.interactionModel.type.DefinitionData} slotType
             */
            SkillManagementServiceClient.prototype.createInteractionModelSlotTypeV1 = function (slotType) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callCreateInteractionModelSlotTypeV1(slotType)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Delete the slot type.
             * @param {string} slotTypeId The identifier for a slot type.
             */
            SkillManagementServiceClient.prototype.callDeleteInteractionModelSlotTypeV1 = function (slotTypeId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callDeleteInteractionModelSlotTypeV1';
                                // verify required parameter 'slotTypeId' is not null or undefined
                                if (slotTypeId == null) {
                                    throw new Error("Required parameter slotTypeId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('slotTypeId', slotTypeId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/api/custom/interactionModel/slotTypes/{slotTypeId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "No content; just confirm the slot type is deleted.");
                                errorDefinitions.set(400, "The slot type cannot be deleted from reasons due to in-use by other entities.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "There is no slot type defined for the slotTypeId.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("DELETE", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Delete the slot type.
             * @param {string} slotTypeId The identifier for a slot type.
             */
            SkillManagementServiceClient.prototype.deleteInteractionModelSlotTypeV1 = function (slotTypeId) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callDeleteInteractionModelSlotTypeV1(slotTypeId)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Get the slot type definition.
             * @param {string} slotTypeId The identifier for a slot type.
             */
            SkillManagementServiceClient.prototype.callGetInteractionModelSlotTypeDefinitionV1 = function (slotTypeId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetInteractionModelSlotTypeDefinitionV1';
                                // verify required parameter 'slotTypeId' is not null or undefined
                                if (slotTypeId == null) {
                                    throw new Error("Required parameter slotTypeId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('slotTypeId', slotTypeId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/api/custom/interactionModel/slotTypes/{slotTypeId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "The slot type definition.");
                                errorDefinitions.set(400, "The slot type cannot be retrieved due to errors listed.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "There is no slot type defined for the slotTypeId.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Get the slot type definition.
             * @param {string} slotTypeId The identifier for a slot type.
             */
            SkillManagementServiceClient.prototype.getInteractionModelSlotTypeDefinitionV1 = function (slotTypeId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetInteractionModelSlotTypeDefinitionV1(slotTypeId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Update description and vendorGuidance string for certain version of a slot type.
             * @param {string} slotTypeId The identifier for a slot type.
             * @param {v1.skill.interactionModel.type.UpdateRequest} updateRequest
             */
            SkillManagementServiceClient.prototype.callUpdateInteractionModelSlotTypeV1 = function (slotTypeId, updateRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callUpdateInteractionModelSlotTypeV1';
                                // verify required parameter 'slotTypeId' is not null or undefined
                                if (slotTypeId == null) {
                                    throw new Error("Required parameter slotTypeId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'updateRequest' is not null or undefined
                                if (updateRequest == null) {
                                    throw new Error("Required parameter updateRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('slotTypeId', slotTypeId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/api/custom/interactionModel/slotTypes/{slotTypeId}/update";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "No content, indicates the fields were successfully updated.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "There is no slot type defined for the slotTypeId.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, updateRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Update description and vendorGuidance string for certain version of a slot type.
             * @param {string} slotTypeId The identifier for a slot type.
             * @param {v1.skill.interactionModel.type.UpdateRequest} updateRequest
             */
            SkillManagementServiceClient.prototype.updateInteractionModelSlotTypeV1 = function (slotTypeId, updateRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callUpdateInteractionModelSlotTypeV1(slotTypeId, updateRequest)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Get the status of slot type resource and its sub-resources for a given slotTypeId.
             * @param {string} slotTypeId The identifier for a slot type.
             * @param {string} updateRequestId The identifier for slotType version creation process
             */
            SkillManagementServiceClient.prototype.callGetInteractionModelSlotTypeBuildStatusV1 = function (slotTypeId, updateRequestId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetInteractionModelSlotTypeBuildStatusV1';
                                // verify required parameter 'slotTypeId' is not null or undefined
                                if (slotTypeId == null) {
                                    throw new Error("Required parameter slotTypeId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'updateRequestId' is not null or undefined
                                if (updateRequestId == null) {
                                    throw new Error("Required parameter updateRequestId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('slotTypeId', slotTypeId);
                                pathParams.set('updateRequestId', updateRequestId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/api/custom/interactionModel/slotTypes/{slotTypeId}/updateRequest/{updateRequestId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns the build status and error codes for the given slotTypeId.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "There is no slot type defined for the slotTypeId.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Get the status of slot type resource and its sub-resources for a given slotTypeId.
             * @param {string} slotTypeId The identifier for a slot type.
             * @param {string} updateRequestId The identifier for slotType version creation process
             */
            SkillManagementServiceClient.prototype.getInteractionModelSlotTypeBuildStatusV1 = function (slotTypeId, updateRequestId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetInteractionModelSlotTypeBuildStatusV1(slotTypeId, updateRequestId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * List all slot type versions for the slot type id.
             * @param {string} slotTypeId The identifier for a slot type.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {string} sortDirection Sets the sorting direction of the result items. When set to &#39;asc&#39; these items are returned in ascending order of sortField value and when set to &#39;desc&#39; these items are returned in descending order of sortField value.
             */
            SkillManagementServiceClient.prototype.callListInteractionModelSlotTypeVersionsV1 = function (slotTypeId, maxResults, nextToken, sortDirection) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, maxResultsValues, nextTokenValues, sortDirectionValues, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callListInteractionModelSlotTypeVersionsV1';
                                // verify required parameter 'slotTypeId' is not null or undefined
                                if (slotTypeId == null) {
                                    throw new Error("Required parameter slotTypeId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (maxResults != null) {
                                    maxResultsValues = Array.isArray(maxResults) ? maxResults : [maxResults];
                                    maxResultsValues.forEach(function (val) { return queryParams.push({ key: 'maxResults', value: val.toString() }); });
                                }
                                if (nextToken != null) {
                                    nextTokenValues = Array.isArray(nextToken) ? nextToken : [nextToken];
                                    nextTokenValues.forEach(function (val) { return queryParams.push({ key: 'nextToken', value: val }); });
                                }
                                if (sortDirection != null) {
                                    sortDirectionValues = Array.isArray(sortDirection) ? sortDirection : [sortDirection];
                                    sortDirectionValues.forEach(function (val) { return queryParams.push({ key: 'sortDirection', value: val }); });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('slotTypeId', slotTypeId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/api/custom/interactionModel/slotTypes/{slotTypeId}/versions";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns list of slot type version for the slot type id.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * List all slot type versions for the slot type id.
             * @param {string} slotTypeId The identifier for a slot type.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {string} sortDirection Sets the sorting direction of the result items. When set to &#39;asc&#39; these items are returned in ascending order of sortField value and when set to &#39;desc&#39; these items are returned in descending order of sortField value.
             */
            SkillManagementServiceClient.prototype.listInteractionModelSlotTypeVersionsV1 = function (slotTypeId, maxResults, nextToken, sortDirection) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callListInteractionModelSlotTypeVersionsV1(slotTypeId, maxResults, nextToken, sortDirection)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Create a new version of slot type entity for the given slotTypeId.
             * @param {string} slotTypeId The identifier for a slot type.
             * @param {v1.skill.interactionModel.typeVersion.VersionData} slotType
             */
            SkillManagementServiceClient.prototype.callCreateInteractionModelSlotTypeVersionV1 = function (slotTypeId, slotType) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callCreateInteractionModelSlotTypeVersionV1';
                                // verify required parameter 'slotTypeId' is not null or undefined
                                if (slotTypeId == null) {
                                    throw new Error("Required parameter slotTypeId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'slotType' is not null or undefined
                                if (slotType == null) {
                                    throw new Error("Required parameter slotType was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('slotTypeId', slotTypeId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/api/custom/interactionModel/slotTypes/{slotTypeId}/versions";
                                errorDefinitions = new Map();
                                errorDefinitions.set(202, "Returns update status location link on success.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error e.g. the slot type definition is invalid.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The specified slot type does not exist.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, slotType, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Create a new version of slot type entity for the given slotTypeId.
             * @param {string} slotTypeId The identifier for a slot type.
             * @param {v1.skill.interactionModel.typeVersion.VersionData} slotType
             */
            SkillManagementServiceClient.prototype.createInteractionModelSlotTypeVersionV1 = function (slotTypeId, slotType) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callCreateInteractionModelSlotTypeVersionV1(slotTypeId, slotType)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Delete slot type version.
             * @param {string} slotTypeId The identifier for a slot type.
             * @param {string} version Version for interaction model.
             */
            SkillManagementServiceClient.prototype.callDeleteInteractionModelSlotTypeVersionV1 = function (slotTypeId, version) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callDeleteInteractionModelSlotTypeVersionV1';
                                // verify required parameter 'slotTypeId' is not null or undefined
                                if (slotTypeId == null) {
                                    throw new Error("Required parameter slotTypeId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'version' is not null or undefined
                                if (version == null) {
                                    throw new Error("Required parameter version was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('slotTypeId', slotTypeId);
                                pathParams.set('version', version);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/api/custom/interactionModel/slotTypes/{slotTypeId}/versions/{version}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "No Content; Confirms that version is successfully deleted.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "There is no slot type version for this slotTypeId.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("DELETE", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Delete slot type version.
             * @param {string} slotTypeId The identifier for a slot type.
             * @param {string} version Version for interaction model.
             */
            SkillManagementServiceClient.prototype.deleteInteractionModelSlotTypeVersionV1 = function (slotTypeId, version) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callDeleteInteractionModelSlotTypeVersionV1(slotTypeId, version)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Get slot type version data of given slot type version.
             * @param {string} slotTypeId The identifier for a slot type.
             * @param {string} version Version for interaction model.
             */
            SkillManagementServiceClient.prototype.callGetInteractionModelSlotTypeVersionV1 = function (slotTypeId, version) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetInteractionModelSlotTypeVersionV1';
                                // verify required parameter 'slotTypeId' is not null or undefined
                                if (slotTypeId == null) {
                                    throw new Error("Required parameter slotTypeId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'version' is not null or undefined
                                if (version == null) {
                                    throw new Error("Required parameter version was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('slotTypeId', slotTypeId);
                                pathParams.set('version', version);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/api/custom/interactionModel/slotTypes/{slotTypeId}/versions/{version}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns the slot type version metadata for the given slotTypeId and version.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "There is no slot type defined for the slotTypeId.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Get slot type version data of given slot type version.
             * @param {string} slotTypeId The identifier for a slot type.
             * @param {string} version Version for interaction model.
             */
            SkillManagementServiceClient.prototype.getInteractionModelSlotTypeVersionV1 = function (slotTypeId, version) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetInteractionModelSlotTypeVersionV1(slotTypeId, version)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Update description and vendorGuidance string for certain version of a slot type.
             * @param {string} slotTypeId The identifier for a slot type.
             * @param {string} version Version for interaction model.
             * @param {v1.skill.interactionModel.typeVersion.SlotTypeUpdate} slotTypeUpdate
             */
            SkillManagementServiceClient.prototype.callUpdateInteractionModelSlotTypeVersionV1 = function (slotTypeId, version, slotTypeUpdate) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callUpdateInteractionModelSlotTypeVersionV1';
                                // verify required parameter 'slotTypeId' is not null or undefined
                                if (slotTypeId == null) {
                                    throw new Error("Required parameter slotTypeId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'version' is not null or undefined
                                if (version == null) {
                                    throw new Error("Required parameter version was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'slotTypeUpdate' is not null or undefined
                                if (slotTypeUpdate == null) {
                                    throw new Error("Required parameter slotTypeUpdate was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('slotTypeId', slotTypeId);
                                pathParams.set('version', version);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/api/custom/interactionModel/slotTypes/{slotTypeId}/versions/{version}/update";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "No Content; Confirms that version is successfully updated.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "There is no slot type defined for the slotTypeId.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, slotTypeUpdate, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Update description and vendorGuidance string for certain version of a slot type.
             * @param {string} slotTypeId The identifier for a slot type.
             * @param {string} version Version for interaction model.
             * @param {v1.skill.interactionModel.typeVersion.SlotTypeUpdate} slotTypeUpdate
             */
            SkillManagementServiceClient.prototype.updateInteractionModelSlotTypeVersionV1 = function (slotTypeId, version, slotTypeUpdate) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callUpdateInteractionModelSlotTypeVersionV1(slotTypeId, version, slotTypeUpdate)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Get status for given exportId
             * @param {string} exportId The Export ID.
             */
            SkillManagementServiceClient.prototype.callGetStatusOfExportRequestV1 = function (exportId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetStatusOfExportRequestV1';
                                // verify required parameter 'exportId' is not null or undefined
                                if (exportId == null) {
                                    throw new Error("Required parameter exportId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('exportId', exportId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/exports/{exportId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "OK.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Get status for given exportId
             * @param {string} exportId The Export ID.
             */
            SkillManagementServiceClient.prototype.getStatusOfExportRequestV1 = function (exportId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetStatusOfExportRequestV1(exportId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Get the list of skills for the vendor.
             * @param {string} vendorId The vendor ID.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {Array<string>} skillId The list of skillIds that you wish to get the summary for. A maximum of 10 skillIds can be specified to get the skill summary in single listSkills call. Please note that this parameter must not be used with &#39;nextToken&#39; or/and &#39;maxResults&#39; parameter.
             */
            SkillManagementServiceClient.prototype.callListSkillsForVendorV1 = function (vendorId, nextToken, maxResults, skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, vendorIdValues, nextTokenValues, maxResultsValues, skillIdValues, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callListSkillsForVendorV1';
                                // verify required parameter 'vendorId' is not null or undefined
                                if (vendorId == null) {
                                    throw new Error("Required parameter vendorId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                vendorIdValues = Array.isArray(vendorId) ? vendorId : [vendorId];
                                vendorIdValues.forEach(function (val) { return queryParams.push({ key: 'vendorId', value: val }); });
                                if (nextToken != null) {
                                    nextTokenValues = Array.isArray(nextToken) ? nextToken : [nextToken];
                                    nextTokenValues.forEach(function (val) { return queryParams.push({ key: 'nextToken', value: val }); });
                                }
                                if (maxResults != null) {
                                    maxResultsValues = Array.isArray(maxResults) ? maxResults : [maxResults];
                                    maxResultsValues.forEach(function (val) { return queryParams.push({ key: 'maxResults', value: val.toString() }); });
                                }
                                if (skillId != null) {
                                    skillIdValues = Array.isArray(skillId) ? skillId : [skillId];
                                    skillIdValues.forEach(function (val) { return queryParams.push({ key: 'skillId', value: val.toString() }); });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns list of skills for the vendor.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Get the list of skills for the vendor.
             * @param {string} vendorId The vendor ID.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {Array<string>} skillId The list of skillIds that you wish to get the summary for. A maximum of 10 skillIds can be specified to get the skill summary in single listSkills call. Please note that this parameter must not be used with &#39;nextToken&#39; or/and &#39;maxResults&#39; parameter.
             */
            SkillManagementServiceClient.prototype.listSkillsForVendorV1 = function (vendorId, nextToken, maxResults, skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callListSkillsForVendorV1(vendorId, nextToken, maxResults, skillId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Get status for given importId.
             * @param {string} importId The Import ID.
             */
            SkillManagementServiceClient.prototype.callGetImportStatusV1 = function (importId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetImportStatusV1';
                                // verify required parameter 'importId' is not null or undefined
                                if (importId == null) {
                                    throw new Error("Required parameter importId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('importId', importId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/imports/{importId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "OK.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Get status for given importId.
             * @param {string} importId The Import ID.
             */
            SkillManagementServiceClient.prototype.getImportStatusV1 = function (importId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetImportStatusV1(importId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Creates a new import for a skill.
             * @param {v1.skill.CreateSkillWithPackageRequest} createSkillWithPackageRequest Defines the request body for createPackage API.
             */
            SkillManagementServiceClient.prototype.callCreateSkillPackageV1 = function (createSkillWithPackageRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callCreateSkillPackageV1';
                                // verify required parameter 'createSkillWithPackageRequest' is not null or undefined
                                if (createSkillWithPackageRequest == null) {
                                    throw new Error("Required parameter createSkillWithPackageRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/imports";
                                errorDefinitions = new Map();
                                errorDefinitions.set(202, "Accepted.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(409, "The request could not be completed due to a conflict with the current state of the target resource.");
                                errorDefinitions.set(413, "Payload too large.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, createSkillWithPackageRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Creates a new import for a skill.
             * @param {v1.skill.CreateSkillWithPackageRequest} createSkillWithPackageRequest Defines the request body for createPackage API.
             */
            SkillManagementServiceClient.prototype.createSkillPackageV1 = function (createSkillWithPackageRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callCreateSkillPackageV1(createSkillWithPackageRequest)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Creates a new skill for given vendorId.
             * @param {v1.skill.CreateSkillRequest} createSkillRequest Defines the request body for createSkill API.
             */
            SkillManagementServiceClient.prototype.callCreateSkillForVendorV1 = function (createSkillRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callCreateSkillForVendorV1';
                                // verify required parameter 'createSkillRequest' is not null or undefined
                                if (createSkillRequest == null) {
                                    throw new Error("Required parameter createSkillRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills";
                                errorDefinitions = new Map();
                                errorDefinitions.set(202, "Accepted; Returns a URL to track the status in &#39;Location&#39; header.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, createSkillRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Creates a new skill for given vendorId.
             * @param {v1.skill.CreateSkillRequest} createSkillRequest Defines the request body for createSkill API.
             */
            SkillManagementServiceClient.prototype.createSkillForVendorV1 = function (createSkillRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callCreateSkillForVendorV1(createSkillRequest)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * GetResourceSchema API provides schema for skill related resources. The schema returned by this API will be specific to vendor because it considers public beta features allowed for the vendor.
             * @param {string} resource Name of the ASK resource for which schema is requested.
             * @param {string} vendorId The vendor ID.
             * @param {string} operation This parameter is required when resource is manifest because skill manifest schema differs based on operation. For example, submit for certification schema has more validations than create skill schema.
             */
            SkillManagementServiceClient.prototype.callGetResourceSchemaV1 = function (resource, vendorId, operation) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, vendorIdValues, operationValues, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetResourceSchemaV1';
                                // verify required parameter 'resource' is not null or undefined
                                if (resource == null) {
                                    throw new Error("Required parameter resource was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'vendorId' is not null or undefined
                                if (vendorId == null) {
                                    throw new Error("Required parameter vendorId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                vendorIdValues = Array.isArray(vendorId) ? vendorId : [vendorId];
                                vendorIdValues.forEach(function (val) { return queryParams.push({ key: 'vendorId', value: val }); });
                                if (operation != null) {
                                    operationValues = Array.isArray(operation) ? operation : [operation];
                                    operationValues.forEach(function (val) { return queryParams.push({ key: 'operation', value: val }); });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('resource', resource);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/resourceSchema/{resource}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns a S3 presigned URL to location of schema");
                                errorDefinitions.set(400, "Invalid request");
                                errorDefinitions.set(401, "Unauthorized");
                                errorDefinitions.set(403, "Forbidden");
                                errorDefinitions.set(429, "Too Many Requests");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * GetResourceSchema API provides schema for skill related resources. The schema returned by this API will be specific to vendor because it considers public beta features allowed for the vendor.
             * @param {string} resource Name of the ASK resource for which schema is requested.
             * @param {string} vendorId The vendor ID.
             * @param {string} operation This parameter is required when resource is manifest because skill manifest schema differs based on operation. For example, submit for certification schema has more validations than create skill schema.
             */
            SkillManagementServiceClient.prototype.getResourceSchemaV1 = function (resource, vendorId, operation) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetResourceSchemaV1(resource, vendorId, operation)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Get Alexa hosted skill's metadata
             * @param {string} skillId The skill ID.
             */
            SkillManagementServiceClient.prototype.callGetAlexaHostedSkillMetadataV1 = function (skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetAlexaHostedSkillMetadataV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/alexaHosted";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "response contains the Alexa hosted skill&#39;s metadata");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error e.g. Authorization Url is invalid");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Get Alexa hosted skill's metadata
             * @param {string} skillId The skill ID.
             */
            SkillManagementServiceClient.prototype.getAlexaHostedSkillMetadataV1 = function (skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetAlexaHostedSkillMetadataV1(skillId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Generates hosted skill repository credentials to access the hosted skill repository.
             * @param {string} skillId The skill ID.
             * @param {v1.skill.AlexaHosted.HostedSkillRepositoryCredentialsRequest} hostedSkillRepositoryCredentialsRequest defines the request body for hosted skill repository credentials
             */
            SkillManagementServiceClient.prototype.callGenerateCredentialsForAlexaHostedSkillV1 = function (skillId, hostedSkillRepositoryCredentialsRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGenerateCredentialsForAlexaHostedSkillV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'hostedSkillRepositoryCredentialsRequest' is not null or undefined
                                if (hostedSkillRepositoryCredentialsRequest == null) {
                                    throw new Error("Required parameter hostedSkillRepositoryCredentialsRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/alexaHosted/repository/credentials/generate";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Response contains the hosted skill repository credentials");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error e.g. Authorization Url is invalid");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, hostedSkillRepositoryCredentialsRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Generates hosted skill repository credentials to access the hosted skill repository.
             * @param {string} skillId The skill ID.
             * @param {v1.skill.AlexaHosted.HostedSkillRepositoryCredentialsRequest} hostedSkillRepositoryCredentialsRequest defines the request body for hosted skill repository credentials
             */
            SkillManagementServiceClient.prototype.generateCredentialsForAlexaHostedSkillV1 = function (skillId, hostedSkillRepositoryCredentialsRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGenerateCredentialsForAlexaHostedSkillV1(skillId, hostedSkillRepositoryCredentialsRequest)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} annotationSetId Identifier of the ASR annotation set.
             * @param {string} accept - &#x60;application/json&#x60;: indicate to download annotation set contents in JSON format - &#x60;text/csv&#x60;: indicate to download annotation set contents in CSV format
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. Defaults to 1000. If more results are present, the response will contain a paginationContext.
             */
            SkillManagementServiceClient.prototype.callGetAnnotationsForASRAnnotationSetV1 = function (skillId, annotationSetId, accept, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, nextTokenValues, maxResultsValues, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetAnnotationsForASRAnnotationSetV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'annotationSetId' is not null or undefined
                                if (annotationSetId == null) {
                                    throw new Error("Required parameter annotationSetId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'accept' is not null or undefined
                                if (accept == null) {
                                    throw new Error("Required parameter accept was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (nextToken != null) {
                                    nextTokenValues = Array.isArray(nextToken) ? nextToken : [nextToken];
                                    nextTokenValues.forEach(function (val) { return queryParams.push({ key: 'nextToken', value: val }); });
                                }
                                if (maxResults != null) {
                                    maxResultsValues = Array.isArray(maxResults) ? maxResults : [maxResults];
                                    maxResultsValues.forEach(function (val) { return queryParams.push({ key: 'maxResults', value: val.toString() }); });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                headerParams.push({ key: 'Accept', value: accept });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('annotationSetId', annotationSetId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/asrAnnotationSets/{annotationSetId}/annotations";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "The annotation set contents payload in specified format.  This API also supports pagination for annotation set contents requested in  &#x60;application/json&#x60; content type. Paginaiton for requested content  type &#x60;text/csv&#x60; is not supported. In this case, the nextToken and  maxResults query parameters would be ignored even if they are  specified as query parameters. ");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                errorDefinitions.set(0, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} annotationSetId Identifier of the ASR annotation set.
             * @param {string} accept - &#x60;application/json&#x60;: indicate to download annotation set contents in JSON format - &#x60;text/csv&#x60;: indicate to download annotation set contents in CSV format
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. Defaults to 1000. If more results are present, the response will contain a paginationContext.
             */
            SkillManagementServiceClient.prototype.getAnnotationsForASRAnnotationSetV1 = function (skillId, annotationSetId, accept, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetAnnotationsForASRAnnotationSetV1(skillId, annotationSetId, accept, nextToken, maxResults)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * API that updates the annotaions in the annotation set
             * @param {string} skillId The skill ID.
             * @param {string} annotationSetId Identifier of the ASR annotation set.
             * @param {v1.skill.asr.annotationSets.UpdateAsrAnnotationSetContentsPayload} updateAsrAnnotationSetContentsRequest Payload containing annotation set contents. Two formats are accepted here: - &#x60;application/json&#x60;: Annotation set payload in JSON format. - &#x60;text/csv&#x60;: Annotation set payload in CSV format. Note that for CSV format, the first row should describe the column attributes. Columns should be delimited by comma.  The subsequent rows should describe annotation data and each annotation attributes has to follow the strict ordering defined in the first row. Each annotation fields should be delimited by comma.
             */
            SkillManagementServiceClient.prototype.callSetAnnotationsForASRAnnotationSetV1 = function (skillId, annotationSetId, updateAsrAnnotationSetContentsRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callSetAnnotationsForASRAnnotationSetV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'annotationSetId' is not null or undefined
                                if (annotationSetId == null) {
                                    throw new Error("Required parameter annotationSetId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'updateAsrAnnotationSetContentsRequest' is not null or undefined
                                if (updateAsrAnnotationSetContentsRequest == null) {
                                    throw new Error("Required parameter updateAsrAnnotationSetContentsRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('annotationSetId', annotationSetId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/asrAnnotationSets/{annotationSetId}/annotations";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "ASR annotation set contents have been updated successfully.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                errorDefinitions.set(0, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("PUT", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, updateAsrAnnotationSetContentsRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * API that updates the annotaions in the annotation set
             * @param {string} skillId The skill ID.
             * @param {string} annotationSetId Identifier of the ASR annotation set.
             * @param {v1.skill.asr.annotationSets.UpdateAsrAnnotationSetContentsPayload} updateAsrAnnotationSetContentsRequest Payload containing annotation set contents. Two formats are accepted here: - &#x60;application/json&#x60;: Annotation set payload in JSON format. - &#x60;text/csv&#x60;: Annotation set payload in CSV format. Note that for CSV format, the first row should describe the column attributes. Columns should be delimited by comma.  The subsequent rows should describe annotation data and each annotation attributes has to follow the strict ordering defined in the first row. Each annotation fields should be delimited by comma.
             */
            SkillManagementServiceClient.prototype.setAnnotationsForASRAnnotationSetV1 = function (skillId, annotationSetId, updateAsrAnnotationSetContentsRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callSetAnnotationsForASRAnnotationSetV1(skillId, annotationSetId, updateAsrAnnotationSetContentsRequest)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * API which deletes the ASR annotation set. Developers cannot get/list the deleted annotation set.
             * @param {string} skillId The skill ID.
             * @param {string} annotationSetId Identifier of the ASR annotation set.
             */
            SkillManagementServiceClient.prototype.callDeleteASRAnnotationSetV1 = function (skillId, annotationSetId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callDeleteASRAnnotationSetV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'annotationSetId' is not null or undefined
                                if (annotationSetId == null) {
                                    throw new Error("Required parameter annotationSetId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('annotationSetId', annotationSetId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/asrAnnotationSets/{annotationSetId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "ASR annotation set exists and is deleted successfully.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(409, "The request could not be completed due to a conflict with the current state of the target resource.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                errorDefinitions.set(0, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("DELETE", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * API which deletes the ASR annotation set. Developers cannot get/list the deleted annotation set.
             * @param {string} skillId The skill ID.
             * @param {string} annotationSetId Identifier of the ASR annotation set.
             */
            SkillManagementServiceClient.prototype.deleteASRAnnotationSetV1 = function (skillId, annotationSetId) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callDeleteASRAnnotationSetV1(skillId, annotationSetId)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Return the metadata for an ASR annotation set.
             * @param {string} skillId The skill ID.
             * @param {string} annotationSetId Identifier of the ASR annotation set.
             */
            SkillManagementServiceClient.prototype.callGetASRAnnotationSetV1 = function (skillId, annotationSetId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetASRAnnotationSetV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'annotationSetId' is not null or undefined
                                if (annotationSetId == null) {
                                    throw new Error("Required parameter annotationSetId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('annotationSetId', annotationSetId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/asrAnnotationSets/{annotationSetId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "The ASR annotation set exists.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                errorDefinitions.set(0, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Return the metadata for an ASR annotation set.
             * @param {string} skillId The skill ID.
             * @param {string} annotationSetId Identifier of the ASR annotation set.
             */
            SkillManagementServiceClient.prototype.getASRAnnotationSetV1 = function (skillId, annotationSetId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetASRAnnotationSetV1(skillId, annotationSetId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * API which updates the ASR annotation set properties. Currently, the only data can be updated is annotation set name.
             * @param {string} skillId The skill ID.
             * @param {string} annotationSetId Identifier of the ASR annotation set.
             * @param {v1.skill.asr.annotationSets.UpdateAsrAnnotationSetPropertiesRequestObject} updateAsrAnnotationSetPropertiesRequestV1 Payload sent to the update ASR annotation set properties API.
             */
            SkillManagementServiceClient.prototype.callSetASRAnnotationSetV1 = function (skillId, annotationSetId, updateAsrAnnotationSetPropertiesRequestV1) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callSetASRAnnotationSetV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'annotationSetId' is not null or undefined
                                if (annotationSetId == null) {
                                    throw new Error("Required parameter annotationSetId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'updateAsrAnnotationSetPropertiesRequestV1' is not null or undefined
                                if (updateAsrAnnotationSetPropertiesRequestV1 == null) {
                                    throw new Error("Required parameter updateAsrAnnotationSetPropertiesRequestV1 was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('annotationSetId', annotationSetId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/asrAnnotationSets/{annotationSetId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "ASR annotation set exists and properties are updated successfully.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                errorDefinitions.set(0, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("PUT", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, updateAsrAnnotationSetPropertiesRequestV1, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * API which updates the ASR annotation set properties. Currently, the only data can be updated is annotation set name.
             * @param {string} skillId The skill ID.
             * @param {string} annotationSetId Identifier of the ASR annotation set.
             * @param {v1.skill.asr.annotationSets.UpdateAsrAnnotationSetPropertiesRequestObject} updateAsrAnnotationSetPropertiesRequestV1 Payload sent to the update ASR annotation set properties API.
             */
            SkillManagementServiceClient.prototype.setASRAnnotationSetV1 = function (skillId, annotationSetId, updateAsrAnnotationSetPropertiesRequestV1) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callSetASRAnnotationSetV1(skillId, annotationSetId, updateAsrAnnotationSetPropertiesRequestV1)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * API which requests all the ASR annotation sets for a skill. Returns the annotation set id and properties for each ASR annotation set. Supports paging of results.
             * @param {string} skillId The skill ID.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. Defaults to 1000. If more results are present, the response will contain a paginationContext.
             */
            SkillManagementServiceClient.prototype.callListASRAnnotationSetsV1 = function (skillId, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, nextTokenValues, maxResultsValues, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callListASRAnnotationSetsV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (nextToken != null) {
                                    nextTokenValues = Array.isArray(nextToken) ? nextToken : [nextToken];
                                    nextTokenValues.forEach(function (val) { return queryParams.push({ key: 'nextToken', value: val }); });
                                }
                                if (maxResults != null) {
                                    maxResultsValues = Array.isArray(maxResults) ? maxResults : [maxResults];
                                    maxResultsValues.forEach(function (val) { return queryParams.push({ key: 'maxResults', value: val.toString() }); });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/asrAnnotationSets";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "ASR annotation sets metadata are returned.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                errorDefinitions.set(0, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * API which requests all the ASR annotation sets for a skill. Returns the annotation set id and properties for each ASR annotation set. Supports paging of results.
             * @param {string} skillId The skill ID.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. Defaults to 1000. If more results are present, the response will contain a paginationContext.
             */
            SkillManagementServiceClient.prototype.listASRAnnotationSetsV1 = function (skillId, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callListASRAnnotationSetsV1(skillId, nextToken, maxResults)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * This is an API that creates a new ASR annotation set with a name and returns the annotationSetId which can later be used to retrieve or reference the annotation set
             * @param {string} skillId The skill ID.
             * @param {v1.skill.asr.annotationSets.CreateAsrAnnotationSetRequestObject} createAsrAnnotationSetRequest Payload sent to the create ASR annotation set API.
             */
            SkillManagementServiceClient.prototype.callCreateASRAnnotationSetV1 = function (skillId, createAsrAnnotationSetRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callCreateASRAnnotationSetV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'createAsrAnnotationSetRequest' is not null or undefined
                                if (createAsrAnnotationSetRequest == null) {
                                    throw new Error("Required parameter createAsrAnnotationSetRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/asrAnnotationSets";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "ASR annotation set created successfully.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                errorDefinitions.set(0, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, createAsrAnnotationSetRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * This is an API that creates a new ASR annotation set with a name and returns the annotationSetId which can later be used to retrieve or reference the annotation set
             * @param {string} skillId The skill ID.
             * @param {v1.skill.asr.annotationSets.CreateAsrAnnotationSetRequestObject} createAsrAnnotationSetRequest Payload sent to the create ASR annotation set API.
             */
            SkillManagementServiceClient.prototype.createASRAnnotationSetV1 = function (skillId, createAsrAnnotationSetRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callCreateASRAnnotationSetV1(skillId, createAsrAnnotationSetRequest)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * API which enables the deletion of an evaluation.
             * @param {string} skillId The skill ID.
             * @param {string} evaluationId Identifier of the evaluation.
             */
            SkillManagementServiceClient.prototype.callDeleteASREvaluationV1 = function (skillId, evaluationId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callDeleteASREvaluationV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'evaluationId' is not null or undefined
                                if (evaluationId == null) {
                                    throw new Error("Required parameter evaluationId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('evaluationId', evaluationId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/asrEvaluations/{evaluationId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "ASR evaluation exists and is deleted successfully.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                errorDefinitions.set(0, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("DELETE", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * API which enables the deletion of an evaluation.
             * @param {string} skillId The skill ID.
             * @param {string} evaluationId Identifier of the evaluation.
             */
            SkillManagementServiceClient.prototype.deleteASREvaluationV1 = function (skillId, evaluationId) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callDeleteASREvaluationV1(skillId, evaluationId)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Paginated API which returns the test case results of an evaluation. This should be considered the \"expensive\" operation while GetAsrEvaluationsStatus is \"cheap\".
             * @param {string} skillId The skill ID.
             * @param {string} evaluationId Identifier of the evaluation.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. Defaults to 1000. If more results are present, the response will contain a nextToken.
             * @param {string} status query parameter used to filter evaluation result status.   * &#x60;PASSED&#x60; - filter evaluation result status of &#x60;PASSED&#x60;   * &#x60;FAILED&#x60; - filter evaluation result status of &#x60;FAILED&#x60;
             */
            SkillManagementServiceClient.prototype.callListASREvaluationsResultsV1 = function (skillId, evaluationId, nextToken, maxResults, status) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, nextTokenValues, maxResultsValues, statusValues, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callListASREvaluationsResultsV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'evaluationId' is not null or undefined
                                if (evaluationId == null) {
                                    throw new Error("Required parameter evaluationId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (nextToken != null) {
                                    nextTokenValues = Array.isArray(nextToken) ? nextToken : [nextToken];
                                    nextTokenValues.forEach(function (val) { return queryParams.push({ key: 'nextToken', value: val }); });
                                }
                                if (maxResults != null) {
                                    maxResultsValues = Array.isArray(maxResults) ? maxResults : [maxResults];
                                    maxResultsValues.forEach(function (val) { return queryParams.push({ key: 'maxResults', value: val.toString() }); });
                                }
                                if (status != null) {
                                    statusValues = Array.isArray(status) ? status : [status];
                                    statusValues.forEach(function (val) { return queryParams.push({ key: 'status', value: val }); });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('evaluationId', evaluationId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/asrEvaluations/{evaluationId}/results";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Evaluation exists and its status is queryable.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                errorDefinitions.set(0, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Paginated API which returns the test case results of an evaluation. This should be considered the \"expensive\" operation while GetAsrEvaluationsStatus is \"cheap\".
             * @param {string} skillId The skill ID.
             * @param {string} evaluationId Identifier of the evaluation.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. Defaults to 1000. If more results are present, the response will contain a nextToken.
             * @param {string} status query parameter used to filter evaluation result status.   * &#x60;PASSED&#x60; - filter evaluation result status of &#x60;PASSED&#x60;   * &#x60;FAILED&#x60; - filter evaluation result status of &#x60;FAILED&#x60;
             */
            SkillManagementServiceClient.prototype.listASREvaluationsResultsV1 = function (skillId, evaluationId, nextToken, maxResults, status) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callListASREvaluationsResultsV1(skillId, evaluationId, nextToken, maxResults, status)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * API which requests high level information about the evaluation like the current state of the job, status of the evaluation (if complete). Also returns the request used to start the job, like the number of total evaluations, number of completed evaluations, and start time. This should be considered the \"cheap\" operation while GetAsrEvaluationsResults is \"expensive\".
             * @param {string} skillId The skill ID.
             * @param {string} evaluationId Identifier of the evaluation.
             */
            SkillManagementServiceClient.prototype.callGetASREvaluationStatusV1 = function (skillId, evaluationId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetASREvaluationStatusV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'evaluationId' is not null or undefined
                                if (evaluationId == null) {
                                    throw new Error("Required parameter evaluationId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('evaluationId', evaluationId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/asrEvaluations/{evaluationId}/status";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Evaluation exists and its status is queryable.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                errorDefinitions.set(0, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * API which requests high level information about the evaluation like the current state of the job, status of the evaluation (if complete). Also returns the request used to start the job, like the number of total evaluations, number of completed evaluations, and start time. This should be considered the \"cheap\" operation while GetAsrEvaluationsResults is \"expensive\".
             * @param {string} skillId The skill ID.
             * @param {string} evaluationId Identifier of the evaluation.
             */
            SkillManagementServiceClient.prototype.getASREvaluationStatusV1 = function (skillId, evaluationId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetASREvaluationStatusV1(skillId, evaluationId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * API that allows developers to get historical ASR evaluations they run before.
             * @param {string} skillId The skill ID.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {string} locale locale in bcp 47 format. Used to filter results with the specified locale. If omitted, the response would include all evaluations regardless of what locale was used in the evaluation
             * @param {string} stage Query parameter used to filter evaluations with specified skill stage.   * &#x60;development&#x60; - skill in &#x60;development&#x60; stage   * &#x60;live&#x60; - skill in &#x60;live&#x60; stage
             * @param {string} annotationSetId filter to evaluations started using this annotationSetId
             * @param {number} maxResults Sets the maximum number of results returned in the response body. Defaults to 1000. If more results are present, the response will contain a nextToken.
             */
            SkillManagementServiceClient.prototype.callListASREvaluationsV1 = function (skillId, nextToken, locale, stage, annotationSetId, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, nextTokenValues, localeValues, stageValues, annotationSetIdValues, maxResultsValues, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callListASREvaluationsV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (nextToken != null) {
                                    nextTokenValues = Array.isArray(nextToken) ? nextToken : [nextToken];
                                    nextTokenValues.forEach(function (val) { return queryParams.push({ key: 'nextToken', value: val }); });
                                }
                                if (locale != null) {
                                    localeValues = Array.isArray(locale) ? locale : [locale];
                                    localeValues.forEach(function (val) { return queryParams.push({ key: 'locale', value: val }); });
                                }
                                if (stage != null) {
                                    stageValues = Array.isArray(stage) ? stage : [stage];
                                    stageValues.forEach(function (val) { return queryParams.push({ key: 'stage', value: val }); });
                                }
                                if (annotationSetId != null) {
                                    annotationSetIdValues = Array.isArray(annotationSetId) ? annotationSetId : [annotationSetId];
                                    annotationSetIdValues.forEach(function (val) { return queryParams.push({ key: 'annotationSetId', value: val }); });
                                }
                                if (maxResults != null) {
                                    maxResultsValues = Array.isArray(maxResults) ? maxResults : [maxResults];
                                    maxResultsValues.forEach(function (val) { return queryParams.push({ key: 'maxResults', value: val.toString() }); });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/asrEvaluations";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Evaluations are returned.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                errorDefinitions.set(0, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * API that allows developers to get historical ASR evaluations they run before.
             * @param {string} skillId The skill ID.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {string} locale locale in bcp 47 format. Used to filter results with the specified locale. If omitted, the response would include all evaluations regardless of what locale was used in the evaluation
             * @param {string} stage Query parameter used to filter evaluations with specified skill stage.   * &#x60;development&#x60; - skill in &#x60;development&#x60; stage   * &#x60;live&#x60; - skill in &#x60;live&#x60; stage
             * @param {string} annotationSetId filter to evaluations started using this annotationSetId
             * @param {number} maxResults Sets the maximum number of results returned in the response body. Defaults to 1000. If more results are present, the response will contain a nextToken.
             */
            SkillManagementServiceClient.prototype.listASREvaluationsV1 = function (skillId, nextToken, locale, stage, annotationSetId, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callListASREvaluationsV1(skillId, nextToken, locale, stage, annotationSetId, maxResults)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * This is an asynchronous API that starts an evaluation against the ASR model built by the skill's interaction model. The operation outputs an evaluationId which allows the retrieval of the current status of the operation and the results upon completion. This operation is unified, meaning both internal and external skill developers may use it to evaluate ASR models.
             * @param {v1.skill.asr.evaluations.PostAsrEvaluationsRequestObject} postAsrEvaluationsRequest Payload sent to trigger evaluation run.
             * @param {string} skillId The skill ID.
             */
            SkillManagementServiceClient.prototype.callCreateASREvaluationV1 = function (postAsrEvaluationsRequest, skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callCreateASREvaluationV1';
                                // verify required parameter 'postAsrEvaluationsRequest' is not null or undefined
                                if (postAsrEvaluationsRequest == null) {
                                    throw new Error("Required parameter postAsrEvaluationsRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/asrEvaluations";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Evaluation has successfully begun.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(409, "The request could not be completed due to a conflict with the current state of the target resource.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                errorDefinitions.set(0, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, postAsrEvaluationsRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * This is an asynchronous API that starts an evaluation against the ASR model built by the skill's interaction model. The operation outputs an evaluationId which allows the retrieval of the current status of the operation and the results upon completion. This operation is unified, meaning both internal and external skill developers may use it to evaluate ASR models.
             * @param {v1.skill.asr.evaluations.PostAsrEvaluationsRequestObject} postAsrEvaluationsRequest Payload sent to trigger evaluation run.
             * @param {string} skillId The skill ID.
             */
            SkillManagementServiceClient.prototype.createASREvaluationV1 = function (postAsrEvaluationsRequest, skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callCreateASREvaluationV1(postAsrEvaluationsRequest, skillId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * End a beta test for a given Alexa skill. System will revoke the entitlement of each tester and send access-end notification email to them.
             * @param {string} skillId The skill ID.
             */
            SkillManagementServiceClient.prototype.callEndBetaTestV1 = function (skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callEndBetaTestV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/betaTest/end";
                                errorDefinitions = new Map();
                                errorDefinitions.set(202, "Accept. Return a URL to track the resource in &#39;Location&#39; header.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(409, "The request could not be completed due to a conflict with the current state of the target resource.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * End a beta test for a given Alexa skill. System will revoke the entitlement of each tester and send access-end notification email to them.
             * @param {string} skillId The skill ID.
             */
            SkillManagementServiceClient.prototype.endBetaTestV1 = function (skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callEndBetaTestV1(skillId)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Get beta test for a given Alexa skill.
             * @param {string} skillId The skill ID.
             */
            SkillManagementServiceClient.prototype.callGetBetaTestV1 = function (skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetBetaTestV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/betaTest";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Success.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(409, "Thrown if user tries to request a new simulation while the old simulation is in progress.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Get beta test for a given Alexa skill.
             * @param {string} skillId The skill ID.
             */
            SkillManagementServiceClient.prototype.getBetaTestV1 = function (skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetBetaTestV1(skillId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Create a beta test for a given Alexa skill.
             * @param {string} skillId The skill ID.
             * @param {v1.skill.betaTest.TestBody} createTestBody JSON object containing the details of a beta test used to create the test.
             */
            SkillManagementServiceClient.prototype.callCreateBetaTestV1 = function (skillId, createTestBody) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callCreateBetaTestV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/betaTest";
                                errorDefinitions = new Map();
                                errorDefinitions.set(201, "Success. Return a URL to track the resource in &#39;Location&#39; header.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(409, "The request could not be completed due to a conflict with the current state of the target resource.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, createTestBody, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Create a beta test for a given Alexa skill.
             * @param {string} skillId The skill ID.
             * @param {v1.skill.betaTest.TestBody} createTestBody JSON object containing the details of a beta test used to create the test.
             */
            SkillManagementServiceClient.prototype.createBetaTestV1 = function (skillId, createTestBody) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callCreateBetaTestV1(skillId, createTestBody)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Update a beta test for a given Alexa skill.
             * @param {string} skillId The skill ID.
             * @param {v1.skill.betaTest.TestBody} createTestBody JSON object containing the details of a beta test used to create the test.
             */
            SkillManagementServiceClient.prototype.callUpdateBetaTestV1 = function (skillId, createTestBody) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callUpdateBetaTestV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/betaTest";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Success. No content.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(409, "Thrown if user tries to request a new simulation while the old simulation is in progress.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("PUT", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, createTestBody, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Update a beta test for a given Alexa skill.
             * @param {string} skillId The skill ID.
             * @param {v1.skill.betaTest.TestBody} createTestBody JSON object containing the details of a beta test used to create the test.
             */
            SkillManagementServiceClient.prototype.updateBetaTestV1 = function (skillId, createTestBody) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callUpdateBetaTestV1(skillId, createTestBody)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Start a beta test for a given Alexa skill. System will send invitation emails to each tester in the test, and add entitlement on the acceptance.
             * @param {string} skillId The skill ID.
             */
            SkillManagementServiceClient.prototype.callStartBetaTestV1 = function (skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callStartBetaTestV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/betaTest/start";
                                errorDefinitions = new Map();
                                errorDefinitions.set(202, "Accept. Return a URL to track the resource in &#39;Location&#39; header.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(409, "The request could not be completed due to a conflict with the current state of the target resource.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Start a beta test for a given Alexa skill. System will send invitation emails to each tester in the test, and add entitlement on the acceptance.
             * @param {string} skillId The skill ID.
             */
            SkillManagementServiceClient.prototype.startBetaTestV1 = function (skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callStartBetaTestV1(skillId)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Add testers to a beta test for the given Alexa skill.  System will send invitation email to each tester and add entitlement on the acceptance.
             * @param {string} skillId The skill ID.
             * @param {v1.skill.betaTest.testers.TestersList} testersRequest JSON object containing the email address of beta testers.
             */
            SkillManagementServiceClient.prototype.callAddTestersToBetaTestV1 = function (skillId, testersRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callAddTestersToBetaTestV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'testersRequest' is not null or undefined
                                if (testersRequest == null) {
                                    throw new Error("Required parameter testersRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/betaTest/testers/add";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Success. No content.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(409, "The request could not be completed due to a conflict with the current state of the target resource.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, testersRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Add testers to a beta test for the given Alexa skill.  System will send invitation email to each tester and add entitlement on the acceptance.
             * @param {string} skillId The skill ID.
             * @param {v1.skill.betaTest.testers.TestersList} testersRequest JSON object containing the email address of beta testers.
             */
            SkillManagementServiceClient.prototype.addTestersToBetaTestV1 = function (skillId, testersRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callAddTestersToBetaTestV1(skillId, testersRequest)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * List all testers in a beta test for the given Alexa skill.
             * @param {string} skillId The skill ID.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 500 results, you can add this parameter to your request. The response might contain fewer results than maxResults, but it will never contain more.
             */
            SkillManagementServiceClient.prototype.callGetListOfTestersV1 = function (skillId, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, nextTokenValues, maxResultsValues, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetListOfTestersV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (nextToken != null) {
                                    nextTokenValues = Array.isArray(nextToken) ? nextToken : [nextToken];
                                    nextTokenValues.forEach(function (val) { return queryParams.push({ key: 'nextToken', value: val }); });
                                }
                                if (maxResults != null) {
                                    maxResultsValues = Array.isArray(maxResults) ? maxResults : [maxResults];
                                    maxResultsValues.forEach(function (val) { return queryParams.push({ key: 'maxResults', value: val.toString() }); });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/betaTest/testers";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Success.");
                                errorDefinitions.set(400, "Bad request.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(409, "The request could not be completed due to a conflict with the current state of the target resource.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * List all testers in a beta test for the given Alexa skill.
             * @param {string} skillId The skill ID.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 500 results, you can add this parameter to your request. The response might contain fewer results than maxResults, but it will never contain more.
             */
            SkillManagementServiceClient.prototype.getListOfTestersV1 = function (skillId, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetListOfTestersV1(skillId, nextToken, maxResults)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Remove testers from a beta test for the given Alexa skill.  System will send access end email to each tester and remove entitlement for them.
             * @param {string} skillId The skill ID.
             * @param {v1.skill.betaTest.testers.TestersList} testersRequest JSON object containing the email address of beta testers.
             */
            SkillManagementServiceClient.prototype.callRemoveTestersFromBetaTestV1 = function (skillId, testersRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callRemoveTestersFromBetaTestV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'testersRequest' is not null or undefined
                                if (testersRequest == null) {
                                    throw new Error("Required parameter testersRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/betaTest/testers/remove";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Success. No content.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(409, "The request could not be completed due to a conflict with the current state of the target resource.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, testersRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Remove testers from a beta test for the given Alexa skill.  System will send access end email to each tester and remove entitlement for them.
             * @param {string} skillId The skill ID.
             * @param {v1.skill.betaTest.testers.TestersList} testersRequest JSON object containing the email address of beta testers.
             */
            SkillManagementServiceClient.prototype.removeTestersFromBetaTestV1 = function (skillId, testersRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callRemoveTestersFromBetaTestV1(skillId, testersRequest)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Request feedback from the testers in a beta test for the given Alexa skill.  System will send notification emails to testers to request feedback.
             * @param {string} skillId The skill ID.
             * @param {v1.skill.betaTest.testers.TestersList} testersRequest JSON object containing the email address of beta testers.
             */
            SkillManagementServiceClient.prototype.callRequestFeedbackFromTestersV1 = function (skillId, testersRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callRequestFeedbackFromTestersV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'testersRequest' is not null or undefined
                                if (testersRequest == null) {
                                    throw new Error("Required parameter testersRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/betaTest/testers/requestFeedback";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Success. No content.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(409, "The request could not be completed due to a conflict with the current state of the target resource.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, testersRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Request feedback from the testers in a beta test for the given Alexa skill.  System will send notification emails to testers to request feedback.
             * @param {string} skillId The skill ID.
             * @param {v1.skill.betaTest.testers.TestersList} testersRequest JSON object containing the email address of beta testers.
             */
            SkillManagementServiceClient.prototype.requestFeedbackFromTestersV1 = function (skillId, testersRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callRequestFeedbackFromTestersV1(skillId, testersRequest)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Send reminder to the testers in a beta test for the given Alexa skill.  System will send invitation email to each tester and add entitlement on the acceptance.
             * @param {string} skillId The skill ID.
             * @param {v1.skill.betaTest.testers.TestersList} testersRequest JSON object containing the email address of beta testers.
             */
            SkillManagementServiceClient.prototype.callSendReminderToTestersV1 = function (skillId, testersRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callSendReminderToTestersV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'testersRequest' is not null or undefined
                                if (testersRequest == null) {
                                    throw new Error("Required parameter testersRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/betaTest/testers/sendReminder";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Success. No content.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(409, "The request could not be completed due to a conflict with the current state of the target resource.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, testersRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Send reminder to the testers in a beta test for the given Alexa skill.  System will send invitation email to each tester and add entitlement on the acceptance.
             * @param {string} skillId The skill ID.
             * @param {v1.skill.betaTest.testers.TestersList} testersRequest JSON object containing the email address of beta testers.
             */
            SkillManagementServiceClient.prototype.sendReminderToTestersV1 = function (skillId, testersRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callSendReminderToTestersV1(skillId, testersRequest)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Gets a specific certification resource. The response contains the review tracking information for a skill to show how much time the skill is expected to remain under review by Amazon. Once the review is complete, the response also contains the outcome of the review. Old certifications may not be available, however any ongoing certification would always give a response. If the certification is unavailable the result will return a 404 HTTP status code.
             * @param {string} skillId The skill ID.
             * @param {string} certificationId Id of the certification. Reserved word identifier of mostRecent can be used to get the most recent certification for the skill. Note that the behavior of the API in this case would be the same as when the actual certification id of the most recent certification is used in the request.
             * @param {string} acceptLanguage User&#39;s locale/language in context.
             */
            SkillManagementServiceClient.prototype.callGetCertificationReviewV1 = function (skillId, certificationId, acceptLanguage) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetCertificationReviewV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'certificationId' is not null or undefined
                                if (certificationId == null) {
                                    throw new Error("Required parameter certificationId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (acceptLanguage != null) {
                                    headerParams.push({ key: 'Accept-Language', value: acceptLanguage });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('certificationId', certificationId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/certifications/{certificationId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Successfully retrieved skill certification information.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error e.g. if any request parameter is invalid like certification Id or pagination token etc. If the maxResults is not in the range of 1 to 50, it also qualifies for this error. ");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceeded the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId. ");
                                errorDefinitions.set(500, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Gets a specific certification resource. The response contains the review tracking information for a skill to show how much time the skill is expected to remain under review by Amazon. Once the review is complete, the response also contains the outcome of the review. Old certifications may not be available, however any ongoing certification would always give a response. If the certification is unavailable the result will return a 404 HTTP status code.
             * @param {string} skillId The skill ID.
             * @param {string} certificationId Id of the certification. Reserved word identifier of mostRecent can be used to get the most recent certification for the skill. Note that the behavior of the API in this case would be the same as when the actual certification id of the most recent certification is used in the request.
             * @param {string} acceptLanguage User&#39;s locale/language in context.
             */
            SkillManagementServiceClient.prototype.getCertificationReviewV1 = function (skillId, certificationId, acceptLanguage) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetCertificationReviewV1(skillId, certificationId, acceptLanguage)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Get list of all certifications available for a skill, including information about past certifications and any ongoing certification. The default sort order is descending on skillSubmissionTimestamp for Certifications.
             * @param {string} skillId The skill ID.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             */
            SkillManagementServiceClient.prototype.callGetCertificationsListV1 = function (skillId, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, nextTokenValues, maxResultsValues, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetCertificationsListV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (nextToken != null) {
                                    nextTokenValues = Array.isArray(nextToken) ? nextToken : [nextToken];
                                    nextTokenValues.forEach(function (val) { return queryParams.push({ key: 'nextToken', value: val }); });
                                }
                                if (maxResults != null) {
                                    maxResultsValues = Array.isArray(maxResults) ? maxResults : [maxResults];
                                    maxResultsValues.forEach(function (val) { return queryParams.push({ key: 'maxResults', value: val.toString() }); });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/certifications";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns list of certifications for the skillId.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error e.g. if any request parameter is invalid like certification Id or pagination token etc. If the maxResults is not in the range of 1 to 50, it also qualifies for this error. ");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceeded the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId. ");
                                errorDefinitions.set(500, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Get list of all certifications available for a skill, including information about past certifications and any ongoing certification. The default sort order is descending on skillSubmissionTimestamp for Certifications.
             * @param {string} skillId The skill ID.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             */
            SkillManagementServiceClient.prototype.getCertificationsListV1 = function (skillId, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetCertificationsListV1(skillId, nextToken, maxResults)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Get the client credentials for the skill.
             * @param {string} skillId The skill ID.
             */
            SkillManagementServiceClient.prototype.callGetSkillCredentialsV1 = function (skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetSkillCredentialsV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/credentials";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Response contains the skill credentials.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Get the client credentials for the skill.
             * @param {string} skillId The skill ID.
             */
            SkillManagementServiceClient.prototype.getSkillCredentialsV1 = function (skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetSkillCredentialsV1(skillId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Delete the skill and model for given skillId.
             * @param {string} skillId The skill ID.
             */
            SkillManagementServiceClient.prototype.callDeleteSkillV1 = function (skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callDeleteSkillV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Success. No content.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("DELETE", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Delete the skill and model for given skillId.
             * @param {string} skillId The skill ID.
             */
            SkillManagementServiceClient.prototype.deleteSkillV1 = function (skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callDeleteSkillV1(skillId)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Deletes an existing experiment for a skill.
             * @param {string} skillId The skill ID.
             * @param {string} experimentId Identifies the experiment in a skill.
             */
            SkillManagementServiceClient.prototype.callDeleteExperimentV1 = function (skillId, experimentId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callDeleteExperimentV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'experimentId' is not null or undefined
                                if (experimentId == null) {
                                    throw new Error("Required parameter experimentId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('experimentId', experimentId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/experiments/{experimentId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Success. No content.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(409, "The request could not be completed due to a conflict with the current state of the target resource.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("DELETE", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Deletes an existing experiment for a skill.
             * @param {string} skillId The skill ID.
             * @param {string} experimentId Identifies the experiment in a skill.
             */
            SkillManagementServiceClient.prototype.deleteExperimentV1 = function (skillId, experimentId) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callDeleteExperimentV1(skillId, experimentId)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Updates the exposure of an experiment that is in CREATED or RUNNING state.
             * @param {string} skillId The skill ID.
             * @param {string} experimentId Identifies the experiment in a skill.
             * @param {v1.skill.experiment.UpdateExposureRequest} updateExposureRequest Defines the request body for updating the exposure percentage of a running experiment.
             */
            SkillManagementServiceClient.prototype.callUpdateExposureV1 = function (skillId, experimentId, updateExposureRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callUpdateExposureV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'experimentId' is not null or undefined
                                if (experimentId == null) {
                                    throw new Error("Required parameter experimentId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'updateExposureRequest' is not null or undefined
                                if (updateExposureRequest == null) {
                                    throw new Error("Required parameter updateExposureRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('experimentId', experimentId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/experiments/{experimentId}/exposurePercentage";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Success. No content.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(409, "The request could not be completed due to a conflict with the current state of the target resource.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, updateExposureRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Updates the exposure of an experiment that is in CREATED or RUNNING state.
             * @param {string} skillId The skill ID.
             * @param {string} experimentId Identifies the experiment in a skill.
             * @param {v1.skill.experiment.UpdateExposureRequest} updateExposureRequest Defines the request body for updating the exposure percentage of a running experiment.
             */
            SkillManagementServiceClient.prototype.updateExposureV1 = function (skillId, experimentId, updateExposureRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callUpdateExposureV1(skillId, experimentId, updateExposureRequest)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Retrieves an existing experiment for a skill.
             * @param {string} skillId The skill ID.
             * @param {string} experimentId Identifies the experiment in a skill.
             */
            SkillManagementServiceClient.prototype.callGetExperimentV1 = function (skillId, experimentId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetExperimentV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'experimentId' is not null or undefined
                                if (experimentId == null) {
                                    throw new Error("Required parameter experimentId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('experimentId', experimentId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/experiments/{experimentId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returned skill experiment.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Retrieves an existing experiment for a skill.
             * @param {string} skillId The skill ID.
             * @param {string} experimentId Identifies the experiment in a skill.
             */
            SkillManagementServiceClient.prototype.getExperimentV1 = function (skillId, experimentId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetExperimentV1(skillId, experimentId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Gets a list of all metric snapshots associated with this experiment id. The metric snapshots represent the metric data available for a time range.
             * @param {string} skillId The skill ID.
             * @param {string} experimentId Identifies the experiment in a skill.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             */
            SkillManagementServiceClient.prototype.callListExperimentMetricSnapshotsV1 = function (skillId, experimentId, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, nextTokenValues, maxResultsValues, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callListExperimentMetricSnapshotsV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'experimentId' is not null or undefined
                                if (experimentId == null) {
                                    throw new Error("Required parameter experimentId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (nextToken != null) {
                                    nextTokenValues = Array.isArray(nextToken) ? nextToken : [nextToken];
                                    nextTokenValues.forEach(function (val) { return queryParams.push({ key: 'nextToken', value: val }); });
                                }
                                if (maxResults != null) {
                                    maxResultsValues = Array.isArray(maxResults) ? maxResults : [maxResults];
                                    maxResultsValues.forEach(function (val) { return queryParams.push({ key: 'maxResults', value: val.toString() }); });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('experimentId', experimentId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/experiments/{experimentId}/metricSnapshots";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returned experiment metric snapshots.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Gets a list of all metric snapshots associated with this experiment id. The metric snapshots represent the metric data available for a time range.
             * @param {string} skillId The skill ID.
             * @param {string} experimentId Identifies the experiment in a skill.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             */
            SkillManagementServiceClient.prototype.listExperimentMetricSnapshotsV1 = function (skillId, experimentId, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callListExperimentMetricSnapshotsV1(skillId, experimentId, nextToken, maxResults)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Gets a list of all metric data associated with this experiment's metric snapshot.
             * @param {string} skillId The skill ID.
             * @param {string} experimentId Identifies the experiment in a skill.
             * @param {string} metricSnapshotId Identifies the experiment metric snapshot in a skill experiment. The metric snapshot represents metric data for a date range.
             */
            SkillManagementServiceClient.prototype.callGetExperimentMetricSnapshotV1 = function (skillId, experimentId, metricSnapshotId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetExperimentMetricSnapshotV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'experimentId' is not null or undefined
                                if (experimentId == null) {
                                    throw new Error("Required parameter experimentId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'metricSnapshotId' is not null or undefined
                                if (metricSnapshotId == null) {
                                    throw new Error("Required parameter metricSnapshotId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('experimentId', experimentId);
                                pathParams.set('metricSnapshotId', metricSnapshotId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/experiments/{experimentId}/metricSnapshots/{metricSnapshotId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returned experiment metric data.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Gets a list of all metric data associated with this experiment's metric snapshot.
             * @param {string} skillId The skill ID.
             * @param {string} experimentId Identifies the experiment in a skill.
             * @param {string} metricSnapshotId Identifies the experiment metric snapshot in a skill experiment. The metric snapshot represents metric data for a date range.
             */
            SkillManagementServiceClient.prototype.getExperimentMetricSnapshotV1 = function (skillId, experimentId, metricSnapshotId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetExperimentMetricSnapshotV1(skillId, experimentId, metricSnapshotId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Updates an existing experiment for a skill. Can only be called while the experiment is in CREATED state.
             * @param {string} skillId The skill ID.
             * @param {string} experimentId Identifies the experiment in a skill.
             * @param {v1.skill.experiment.UpdateExperimentRequest} updateExperimentRequest Defines the request body for updating an experiment.
             */
            SkillManagementServiceClient.prototype.callUpdateExperimentV1 = function (skillId, experimentId, updateExperimentRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callUpdateExperimentV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'experimentId' is not null or undefined
                                if (experimentId == null) {
                                    throw new Error("Required parameter experimentId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'updateExperimentRequest' is not null or undefined
                                if (updateExperimentRequest == null) {
                                    throw new Error("Required parameter updateExperimentRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('experimentId', experimentId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/experiments/{experimentId}/properties";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Success. No content.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(409, "The request could not be completed due to a conflict with the current state of the target resource.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, updateExperimentRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Updates an existing experiment for a skill. Can only be called while the experiment is in CREATED state.
             * @param {string} skillId The skill ID.
             * @param {string} experimentId Identifies the experiment in a skill.
             * @param {v1.skill.experiment.UpdateExperimentRequest} updateExperimentRequest Defines the request body for updating an experiment.
             */
            SkillManagementServiceClient.prototype.updateExperimentV1 = function (skillId, experimentId, updateExperimentRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callUpdateExperimentV1(skillId, experimentId, updateExperimentRequest)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Retrieves the current state of the experiment.
             * @param {string} skillId The skill ID.
             * @param {string} experimentId Identifies the experiment in a skill.
             */
            SkillManagementServiceClient.prototype.callGetExperimentStateV1 = function (skillId, experimentId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetExperimentStateV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'experimentId' is not null or undefined
                                if (experimentId == null) {
                                    throw new Error("Required parameter experimentId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('experimentId', experimentId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/experiments/{experimentId}/state";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returned skill experiment state.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Retrieves the current state of the experiment.
             * @param {string} skillId The skill ID.
             * @param {string} experimentId Identifies the experiment in a skill.
             */
            SkillManagementServiceClient.prototype.getExperimentStateV1 = function (skillId, experimentId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetExperimentStateV1(skillId, experimentId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Requests an action on the experiment to move it to the targetState. Acceptable targetState values are: * `ENABLED`: Experiment configurations are deployed and customer overrides are enabled. Actual experiment has not started yet but customers with overrides set to T1 will see the T1 behavior. Initial state must be CREATED. * `RUNNING`: Starts the experiment with the configured exposure. Skill customers selected to be in the experiment will start contributing to the metric data. Initial state must be CREATED or ENABLED. * `STOPPED`: Stops the experiment by removing the experiment configurations. All customer treatment overrides are removed. Initial state must be ENABLED or RUNNING.              Final state for ENDPOINT_BASED experiments, no further action is taken by ASK. It is expected that the skill builder updates their endpoint code to make T1 the default live behavior.
             * @param {string} skillId The skill ID.
             * @param {string} experimentId Identifies the experiment in a skill.
             * @param {v1.skill.experiment.ManageExperimentStateRequest} manageExperimentStateRequest Defines the request body for performing an experiment action to move it to a target state.
             */
            SkillManagementServiceClient.prototype.callManageExperimentStateV1 = function (skillId, experimentId, manageExperimentStateRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callManageExperimentStateV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'experimentId' is not null or undefined
                                if (experimentId == null) {
                                    throw new Error("Required parameter experimentId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'manageExperimentStateRequest' is not null or undefined
                                if (manageExperimentStateRequest == null) {
                                    throw new Error("Required parameter manageExperimentStateRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('experimentId', experimentId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/experiments/{experimentId}/state";
                                errorDefinitions = new Map();
                                errorDefinitions.set(202, "Accepted; Returns a URL to track the experiment state in &#39;Location&#39; header.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(409, "The request could not be completed due to a conflict with the current state of the target resource.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, manageExperimentStateRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Requests an action on the experiment to move it to the targetState. Acceptable targetState values are: * `ENABLED`: Experiment configurations are deployed and customer overrides are enabled. Actual experiment has not started yet but customers with overrides set to T1 will see the T1 behavior. Initial state must be CREATED. * `RUNNING`: Starts the experiment with the configured exposure. Skill customers selected to be in the experiment will start contributing to the metric data. Initial state must be CREATED or ENABLED. * `STOPPED`: Stops the experiment by removing the experiment configurations. All customer treatment overrides are removed. Initial state must be ENABLED or RUNNING.              Final state for ENDPOINT_BASED experiments, no further action is taken by ASK. It is expected that the skill builder updates their endpoint code to make T1 the default live behavior.
             * @param {string} skillId The skill ID.
             * @param {string} experimentId Identifies the experiment in a skill.
             * @param {v1.skill.experiment.ManageExperimentStateRequest} manageExperimentStateRequest Defines the request body for performing an experiment action to move it to a target state.
             */
            SkillManagementServiceClient.prototype.manageExperimentStateV1 = function (skillId, experimentId, manageExperimentStateRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callManageExperimentStateV1(skillId, experimentId, manageExperimentStateRequest)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Retrieves the current user's customer treatment override for an existing A/B Test experiment. The current user must be under the same skill vendor of the requested skill id to have access to the resource.
             * @param {string} skillId The skill ID.
             * @param {string} experimentId Identifies the experiment in a skill.
             */
            SkillManagementServiceClient.prototype.callGetCustomerTreatmentOverrideV1 = function (skillId, experimentId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetCustomerTreatmentOverrideV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'experimentId' is not null or undefined
                                if (experimentId == null) {
                                    throw new Error("Required parameter experimentId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('experimentId', experimentId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/experiments/{experimentId}/treatmentOverrides/~current";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returned customer treatment override details.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Retrieves the current user's customer treatment override for an existing A/B Test experiment. The current user must be under the same skill vendor of the requested skill id to have access to the resource.
             * @param {string} skillId The skill ID.
             * @param {string} experimentId Identifies the experiment in a skill.
             */
            SkillManagementServiceClient.prototype.getCustomerTreatmentOverrideV1 = function (skillId, experimentId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetCustomerTreatmentOverrideV1(skillId, experimentId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Adds the requesting user's customer treatment override to an existing experiment. The current user must be under the same skill vendor of the requested skill id to have access to the resource. Only the current user can attempt to add the override of their own customer account to an experiment. Can only be called before the experiment is enabled.
             * @param {string} skillId The skill ID.
             * @param {string} experimentId Identifies the experiment in a skill.
             * @param {v1.skill.experiment.SetCustomerTreatmentOverrideRequest} setCustomerTreatmentOverrideRequest Defines the request body for adding this customer&#39;s treatment override to an experiment.
             */
            SkillManagementServiceClient.prototype.callSetCustomerTreatmentOverrideV1 = function (skillId, experimentId, setCustomerTreatmentOverrideRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callSetCustomerTreatmentOverrideV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'experimentId' is not null or undefined
                                if (experimentId == null) {
                                    throw new Error("Required parameter experimentId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'setCustomerTreatmentOverrideRequest' is not null or undefined
                                if (setCustomerTreatmentOverrideRequest == null) {
                                    throw new Error("Required parameter setCustomerTreatmentOverrideRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('experimentId', experimentId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/experiments/{experimentId}/treatmentOverrides/~current";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Success. No content.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(409, "The request could not be completed due to a conflict with the current state of the target resource.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("PUT", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, setCustomerTreatmentOverrideRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Adds the requesting user's customer treatment override to an existing experiment. The current user must be under the same skill vendor of the requested skill id to have access to the resource. Only the current user can attempt to add the override of their own customer account to an experiment. Can only be called before the experiment is enabled.
             * @param {string} skillId The skill ID.
             * @param {string} experimentId Identifies the experiment in a skill.
             * @param {v1.skill.experiment.SetCustomerTreatmentOverrideRequest} setCustomerTreatmentOverrideRequest Defines the request body for adding this customer&#39;s treatment override to an experiment.
             */
            SkillManagementServiceClient.prototype.setCustomerTreatmentOverrideV1 = function (skillId, experimentId, setCustomerTreatmentOverrideRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callSetCustomerTreatmentOverrideV1(skillId, experimentId, setCustomerTreatmentOverrideRequest)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Gets a list of all experiments associated with this skill id.
             * @param {string} skillId The skill ID.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             */
            SkillManagementServiceClient.prototype.callListExperimentsV1 = function (skillId, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, nextTokenValues, maxResultsValues, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callListExperimentsV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (nextToken != null) {
                                    nextTokenValues = Array.isArray(nextToken) ? nextToken : [nextToken];
                                    nextTokenValues.forEach(function (val) { return queryParams.push({ key: 'nextToken', value: val }); });
                                }
                                if (maxResults != null) {
                                    maxResultsValues = Array.isArray(maxResults) ? maxResults : [maxResults];
                                    maxResultsValues.forEach(function (val) { return queryParams.push({ key: 'maxResults', value: val.toString() }); });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/experiments";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returned skill experiments.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Gets a list of all experiments associated with this skill id.
             * @param {string} skillId The skill ID.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             */
            SkillManagementServiceClient.prototype.listExperimentsV1 = function (skillId, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callListExperimentsV1(skillId, nextToken, maxResults)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Create a new experiment for a skill.
             * @param {string} skillId The skill ID.
             * @param {v1.skill.experiment.CreateExperimentRequest} createExperimentRequest Defines the request body for creating an experiment.
             */
            SkillManagementServiceClient.prototype.callCreateExperimentV1 = function (skillId, createExperimentRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callCreateExperimentV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'createExperimentRequest' is not null or undefined
                                if (createExperimentRequest == null) {
                                    throw new Error("Required parameter createExperimentRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/experiments";
                                errorDefinitions = new Map();
                                errorDefinitions.set(201, "Experiment created. Returns the generated experiment identifier in &#39;Location&#39; header.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, createExperimentRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Create a new experiment for a skill.
             * @param {string} skillId The skill ID.
             * @param {v1.skill.experiment.CreateExperimentRequest} createExperimentRequest Defines the request body for creating an experiment.
             */
            SkillManagementServiceClient.prototype.createExperimentV1 = function (skillId, createExperimentRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callCreateExperimentV1(skillId, createExperimentRequest)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} stage The stage of the skill to be used for evaluation. An error will be returned if this skill stage is not enabled on the account used for evaluation.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {string} sortDirection Sets the sorting direction of the result items. When set to &#39;asc&#39; these items are returned in ascending order of sortField value and when set to &#39;desc&#39; these items are returned in descending order of sortField value.
             * @param {string} sortField Sets the field on which the sorting would be applied.
             * @param {Array<v1.skill.history.LocaleInQuery>} locale
             * @param {Array<v1.skill.history.DialogActName>} dialogActName A filter used to retrieve items where the dialogAct name is equal to the given value. * &#x60;Dialog.ElicitSlot&#x60;: Alexa asked the user for the value of a specific slot. (https://developer.amazon.com/docs/custom-skills/dialog-interface-reference.html#elicitslot) * &#x60;Dialog.ConfirmSlot&#x60;: Alexa confirmed the value of a specific slot before continuing with the dialog. (https://developer.amazon.com/docs/custom-skills/dialog-interface-reference.html#confirmslot) * &#x60;Dialog.ConfirmIntent&#x60;: Alexa confirmed the all the information the user has provided for the intent before the skill took action. (https://developer.amazon.com/docs/custom-skills/dialog-interface-reference.html#confirmintent)
             * @param {Array<v1.skill.history.IntentConfidenceBin>} intentConfidenceBin
             * @param {Array<string>} intentName A filter used to retrieve items where the intent name is equal to the given value.
             * @param {Array<string>} intentSlotsName A filter used to retrieve items where the one of the slot names is equal to the given value.
             * @param {Array<v1.skill.history.InteractionType>} interactionType
             * @param {Array<v1.skill.history.PublicationStatus>} publicationStatus
             * @param {Array<string>} utteranceText A filter used to retrieve items where the utterance text contains the given phrase. Each filter value can be at-least 1 character and at-most 100 characters long.
             */
            SkillManagementServiceClient.prototype.callGetUtteranceDataV1 = function (skillId, stage, nextToken, maxResults, sortDirection, sortField, locale, dialogActName, intentConfidenceBin, intentName, intentSlotsName, interactionType, publicationStatus, utteranceText) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, nextTokenValues, maxResultsValues, sortDirectionValues, sortFieldValues, stageValues, localeValues, dialogActNameValues, intentConfidenceBinValues, intentNameValues, intentSlotsNameValues, interactionTypeValues, publicationStatusValues, utteranceTextValues, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetUtteranceDataV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (nextToken != null) {
                                    nextTokenValues = Array.isArray(nextToken) ? nextToken : [nextToken];
                                    nextTokenValues.forEach(function (val) { return queryParams.push({ key: 'nextToken', value: val }); });
                                }
                                if (maxResults != null) {
                                    maxResultsValues = Array.isArray(maxResults) ? maxResults : [maxResults];
                                    maxResultsValues.forEach(function (val) { return queryParams.push({ key: 'maxResults', value: val.toString() }); });
                                }
                                if (sortDirection != null) {
                                    sortDirectionValues = Array.isArray(sortDirection) ? sortDirection : [sortDirection];
                                    sortDirectionValues.forEach(function (val) { return queryParams.push({ key: 'sortDirection', value: val }); });
                                }
                                if (sortField != null) {
                                    sortFieldValues = Array.isArray(sortField) ? sortField : [sortField];
                                    sortFieldValues.forEach(function (val) { return queryParams.push({ key: 'sortField', value: val }); });
                                }
                                stageValues = Array.isArray(stage) ? stage : [stage];
                                stageValues.forEach(function (val) { return queryParams.push({ key: 'stage', value: val }); });
                                if (locale != null) {
                                    localeValues = Array.isArray(locale) ? locale : [locale];
                                    localeValues.forEach(function (val) { return queryParams.push({ key: 'locale', value: val.toString() }); });
                                }
                                if (dialogActName != null) {
                                    dialogActNameValues = Array.isArray(dialogActName) ? dialogActName : [dialogActName];
                                    dialogActNameValues.forEach(function (val) { return queryParams.push({ key: 'dialogAct.name', value: val.toString() }); });
                                }
                                if (intentConfidenceBin != null) {
                                    intentConfidenceBinValues = Array.isArray(intentConfidenceBin) ? intentConfidenceBin : [intentConfidenceBin];
                                    intentConfidenceBinValues.forEach(function (val) { return queryParams.push({ key: 'intent.confidence.bin', value: val.toString() }); });
                                }
                                if (intentName != null) {
                                    intentNameValues = Array.isArray(intentName) ? intentName : [intentName];
                                    intentNameValues.forEach(function (val) { return queryParams.push({ key: 'intent.name', value: val.toString() }); });
                                }
                                if (intentSlotsName != null) {
                                    intentSlotsNameValues = Array.isArray(intentSlotsName) ? intentSlotsName : [intentSlotsName];
                                    intentSlotsNameValues.forEach(function (val) { return queryParams.push({ key: 'intent.slots.name', value: val.toString() }); });
                                }
                                if (interactionType != null) {
                                    interactionTypeValues = Array.isArray(interactionType) ? interactionType : [interactionType];
                                    interactionTypeValues.forEach(function (val) { return queryParams.push({ key: 'interactionType', value: val.toString() }); });
                                }
                                if (publicationStatus != null) {
                                    publicationStatusValues = Array.isArray(publicationStatus) ? publicationStatus : [publicationStatus];
                                    publicationStatusValues.forEach(function (val) { return queryParams.push({ key: 'publicationStatus', value: val.toString() }); });
                                }
                                if (utteranceText != null) {
                                    utteranceTextValues = Array.isArray(utteranceText) ? utteranceText : [utteranceText];
                                    utteranceTextValues.forEach(function (val) { return queryParams.push({ key: 'utteranceText', value: val.toString() }); });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/history/intentRequests";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns a list of utterance items for the given skill.");
                                errorDefinitions.set(400, "Bad Request.");
                                errorDefinitions.set(401, "Unauthorized.");
                                errorDefinitions.set(404, "Skill Not Found.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} stage The stage of the skill to be used for evaluation. An error will be returned if this skill stage is not enabled on the account used for evaluation.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {string} sortDirection Sets the sorting direction of the result items. When set to &#39;asc&#39; these items are returned in ascending order of sortField value and when set to &#39;desc&#39; these items are returned in descending order of sortField value.
             * @param {string} sortField Sets the field on which the sorting would be applied.
             * @param {Array<v1.skill.history.LocaleInQuery>} locale
             * @param {Array<v1.skill.history.DialogActName>} dialogActName A filter used to retrieve items where the dialogAct name is equal to the given value. * &#x60;Dialog.ElicitSlot&#x60;: Alexa asked the user for the value of a specific slot. (https://developer.amazon.com/docs/custom-skills/dialog-interface-reference.html#elicitslot) * &#x60;Dialog.ConfirmSlot&#x60;: Alexa confirmed the value of a specific slot before continuing with the dialog. (https://developer.amazon.com/docs/custom-skills/dialog-interface-reference.html#confirmslot) * &#x60;Dialog.ConfirmIntent&#x60;: Alexa confirmed the all the information the user has provided for the intent before the skill took action. (https://developer.amazon.com/docs/custom-skills/dialog-interface-reference.html#confirmintent)
             * @param {Array<v1.skill.history.IntentConfidenceBin>} intentConfidenceBin
             * @param {Array<string>} intentName A filter used to retrieve items where the intent name is equal to the given value.
             * @param {Array<string>} intentSlotsName A filter used to retrieve items where the one of the slot names is equal to the given value.
             * @param {Array<v1.skill.history.InteractionType>} interactionType
             * @param {Array<v1.skill.history.PublicationStatus>} publicationStatus
             * @param {Array<string>} utteranceText A filter used to retrieve items where the utterance text contains the given phrase. Each filter value can be at-least 1 character and at-most 100 characters long.
             */
            SkillManagementServiceClient.prototype.getUtteranceDataV1 = function (skillId, stage, nextToken, maxResults, sortDirection, sortField, locale, dialogActName, intentConfidenceBin, intentName, intentSlotsName, interactionType, publicationStatus, utteranceText) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetUtteranceDataV1(skillId, stage, nextToken, maxResults, sortDirection, sortField, locale, dialogActName, intentConfidenceBin, intentName, intentSlotsName, interactionType, publicationStatus, utteranceText)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Creates a new import for a skill with given skillId.
             * @param {v1.skill.UpdateSkillWithPackageRequest} updateSkillWithPackageRequest Defines the request body for updatePackage API.
             * @param {string} skillId The skill ID.
             * @param {string} ifMatch Request header that specified an entity tag. The server will update the resource only if the eTag matches with the resource&#39;s current eTag.
             */
            SkillManagementServiceClient.prototype.callImportSkillPackageV1 = function (updateSkillWithPackageRequest, skillId, ifMatch) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callImportSkillPackageV1';
                                // verify required parameter 'updateSkillWithPackageRequest' is not null or undefined
                                if (updateSkillWithPackageRequest == null) {
                                    throw new Error("Required parameter updateSkillWithPackageRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (ifMatch != null) {
                                    headerParams.push({ key: 'If-Match', value: ifMatch });
                                }
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/imports";
                                errorDefinitions = new Map();
                                errorDefinitions.set(202, "Accepted.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(409, "The request could not be completed due to a conflict with the current state of the target resource.");
                                errorDefinitions.set(412, "Precondition failed.");
                                errorDefinitions.set(413, "Payload too large.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, updateSkillWithPackageRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Creates a new import for a skill with given skillId.
             * @param {v1.skill.UpdateSkillWithPackageRequest} updateSkillWithPackageRequest Defines the request body for updatePackage API.
             * @param {string} skillId The skill ID.
             * @param {string} ifMatch Request header that specified an entity tag. The server will update the resource only if the eTag matches with the resource&#39;s current eTag.
             */
            SkillManagementServiceClient.prototype.importSkillPackageV1 = function (updateSkillWithPackageRequest, skillId, ifMatch) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callImportSkillPackageV1(updateSkillWithPackageRequest, skillId, ifMatch)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * This is a synchronous API that invokes the Lambda or third party HTTPS endpoint for a given skill. A successful response will contain information related to what endpoint was called, payload sent to and received from the endpoint. In cases where requests to this API results in an error, the response will contain an error code and a description of the problem. In cases where invoking the skill endpoint specifically fails, the response will contain a status attribute indicating that a failure occurred and details about what was sent to the endpoint. The skill must belong to and be enabled by the user of this API. Also, note that calls to the skill endpoint will timeout after 10 seconds.
             * @param {string} skillId The skill ID.
             * @param {v1.skill.invocations.InvokeSkillRequest} invokeSkillRequest Payload sent to the skill invocation API.
             */
            SkillManagementServiceClient.prototype.callInvokeSkillV1 = function (skillId, invokeSkillRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callInvokeSkillV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'invokeSkillRequest' is not null or undefined
                                if (invokeSkillRequest == null) {
                                    throw new Error("Required parameter invokeSkillRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/invocations";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Skill was invoked.");
                                errorDefinitions.set(400, "Bad request due to invalid or missing data.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "API user does not have permission to call this API or is currently in a state that does not allow invocation of this skill. ");
                                errorDefinitions.set(404, "The specified skill does not exist.");
                                errorDefinitions.set(429, "API user has exceeded the permitted request rate.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, invokeSkillRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * This is a synchronous API that invokes the Lambda or third party HTTPS endpoint for a given skill. A successful response will contain information related to what endpoint was called, payload sent to and received from the endpoint. In cases where requests to this API results in an error, the response will contain an error code and a description of the problem. In cases where invoking the skill endpoint specifically fails, the response will contain a status attribute indicating that a failure occurred and details about what was sent to the endpoint. The skill must belong to and be enabled by the user of this API. Also, note that calls to the skill endpoint will timeout after 10 seconds.
             * @param {string} skillId The skill ID.
             * @param {v1.skill.invocations.InvokeSkillRequest} invokeSkillRequest Payload sent to the skill invocation API.
             */
            SkillManagementServiceClient.prototype.invokeSkillV1 = function (skillId, invokeSkillRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callInvokeSkillV1(skillId, invokeSkillRequest)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Get analytic metrics report of skill usage.
             * @param {string} skillId The skill ID.
             * @param {string} startTime The start time of query.
             * @param {string} endTime The end time of query (The maximum time duration is 1 week)
             * @param {string} period The aggregation period to use when retrieving the metric, follows ISO_8601#Durations format.
             * @param {string} metric A distinct set of logic which predictably returns a set of data.
             * @param {string} stage The stage of the skill (live, development).
             * @param {string} skillType The type of the skill (custom, smartHome and flashBriefing).
             * @param {string} intent The intent of the skill.
             * @param {string} locale The locale for the skill. e.g. en-GB, en-US, de-DE and etc.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             */
            SkillManagementServiceClient.prototype.callGetSkillMetricsV1 = function (skillId, startTime, endTime, period, metric, stage, skillType, intent, locale, maxResults, nextToken) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, startTimeValues, endTimeValues, periodValues, metricValues, stageValues, skillTypeValues, intentValues, localeValues, maxResultsValues, nextTokenValues, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetSkillMetricsV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'startTime' is not null or undefined
                                if (startTime == null) {
                                    throw new Error("Required parameter startTime was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'endTime' is not null or undefined
                                if (endTime == null) {
                                    throw new Error("Required parameter endTime was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'period' is not null or undefined
                                if (period == null) {
                                    throw new Error("Required parameter period was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'metric' is not null or undefined
                                if (metric == null) {
                                    throw new Error("Required parameter metric was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'skillType' is not null or undefined
                                if (skillType == null) {
                                    throw new Error("Required parameter skillType was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                startTimeValues = Array.isArray(startTime) ? startTime : [startTime];
                                startTimeValues.forEach(function (val) { return queryParams.push({ key: 'startTime', value: val.toString() }); });
                                endTimeValues = Array.isArray(endTime) ? endTime : [endTime];
                                endTimeValues.forEach(function (val) { return queryParams.push({ key: 'endTime', value: val.toString() }); });
                                periodValues = Array.isArray(period) ? period : [period];
                                periodValues.forEach(function (val) { return queryParams.push({ key: 'period', value: val }); });
                                metricValues = Array.isArray(metric) ? metric : [metric];
                                metricValues.forEach(function (val) { return queryParams.push({ key: 'metric', value: val }); });
                                stageValues = Array.isArray(stage) ? stage : [stage];
                                stageValues.forEach(function (val) { return queryParams.push({ key: 'stage', value: val }); });
                                skillTypeValues = Array.isArray(skillType) ? skillType : [skillType];
                                skillTypeValues.forEach(function (val) { return queryParams.push({ key: 'skillType', value: val }); });
                                if (intent != null) {
                                    intentValues = Array.isArray(intent) ? intent : [intent];
                                    intentValues.forEach(function (val) { return queryParams.push({ key: 'intent', value: val }); });
                                }
                                if (locale != null) {
                                    localeValues = Array.isArray(locale) ? locale : [locale];
                                    localeValues.forEach(function (val) { return queryParams.push({ key: 'locale', value: val }); });
                                }
                                if (maxResults != null) {
                                    maxResultsValues = Array.isArray(maxResults) ? maxResults : [maxResults];
                                    maxResultsValues.forEach(function (val) { return queryParams.push({ key: 'maxResults', value: val.toString() }); });
                                }
                                if (nextToken != null) {
                                    nextTokenValues = Array.isArray(nextToken) ? nextToken : [nextToken];
                                    nextTokenValues.forEach(function (val) { return queryParams.push({ key: 'nextToken', value: val }); });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/metrics";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Get analytic metrics report successfully.");
                                errorDefinitions.set(400, "Bad request due to invalid or missing data.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Get analytic metrics report of skill usage.
             * @param {string} skillId The skill ID.
             * @param {string} startTime The start time of query.
             * @param {string} endTime The end time of query (The maximum time duration is 1 week)
             * @param {string} period The aggregation period to use when retrieving the metric, follows ISO_8601#Durations format.
             * @param {string} metric A distinct set of logic which predictably returns a set of data.
             * @param {string} stage The stage of the skill (live, development).
             * @param {string} skillType The type of the skill (custom, smartHome and flashBriefing).
             * @param {string} intent The intent of the skill.
             * @param {string} locale The locale for the skill. e.g. en-GB, en-US, de-DE and etc.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             */
            SkillManagementServiceClient.prototype.getSkillMetricsV1 = function (skillId, startTime, endTime, period, metric, stage, skillType, intent, locale, maxResults, nextToken) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetSkillMetricsV1(skillId, startTime, endTime, period, metric, stage, skillType, intent, locale, maxResults, nextToken)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} annotationId Identifier of the NLU annotation set.
             * @param {string} accept Standard HTTP. Pass &#x60;application/json&#x60; or &#x60;test/csv&#x60; for GET calls.
             */
            SkillManagementServiceClient.prototype.callGetAnnotationsForNLUAnnotationSetsV1 = function (skillId, annotationId, accept) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetAnnotationsForNLUAnnotationSetsV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'annotationId' is not null or undefined
                                if (annotationId == null) {
                                    throw new Error("Required parameter annotationId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'accept' is not null or undefined
                                if (accept == null) {
                                    throw new Error("Required parameter accept was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                headerParams.push({ key: 'Accept', value: accept });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('annotationId', annotationId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/nluAnnotationSets/{annotationId}/annotations";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "The specific version of a NLU annotation set has the content.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} annotationId Identifier of the NLU annotation set.
             * @param {string} accept Standard HTTP. Pass &#x60;application/json&#x60; or &#x60;test/csv&#x60; for GET calls.
             */
            SkillManagementServiceClient.prototype.getAnnotationsForNLUAnnotationSetsV1 = function (skillId, annotationId, accept) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetAnnotationsForNLUAnnotationSetsV1(skillId, annotationId, accept)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * API which replaces the annotations in NLU annotation set.
             * @param {string} skillId The skill ID.
             * @param {string} annotationId Identifier of the NLU annotation set.
             * @param {string} contentType Standard HTTP. Pass &#x60;application/json&#x60; or &#x60;test/csv&#x60; for POST calls with a json/csv body.
             * @param {v1.skill.nlu.annotationSets.UpdateNLUAnnotationSetAnnotationsRequest} updateNLUAnnotationSetAnnotationsRequest Payload sent to the update NLU annotation set API.
             */
            SkillManagementServiceClient.prototype.callUpdateAnnotationsForNLUAnnotationSetsV1 = function (skillId, annotationId, contentType, updateNLUAnnotationSetAnnotationsRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callUpdateAnnotationsForNLUAnnotationSetsV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'annotationId' is not null or undefined
                                if (annotationId == null) {
                                    throw new Error("Required parameter annotationId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'contentType' is not null or undefined
                                if (contentType == null) {
                                    throw new Error("Required parameter contentType was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'updateNLUAnnotationSetAnnotationsRequest' is not null or undefined
                                if (updateNLUAnnotationSetAnnotationsRequest == null) {
                                    throw new Error("Required parameter updateNLUAnnotationSetAnnotationsRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                headerParams.push({ key: 'Content-Type', value: contentType });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('annotationId', annotationId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/nluAnnotationSets/{annotationId}/annotations";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "NLU annotation set exists and starts the update.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, updateNLUAnnotationSetAnnotationsRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * API which replaces the annotations in NLU annotation set.
             * @param {string} skillId The skill ID.
             * @param {string} annotationId Identifier of the NLU annotation set.
             * @param {string} contentType Standard HTTP. Pass &#x60;application/json&#x60; or &#x60;test/csv&#x60; for POST calls with a json/csv body.
             * @param {v1.skill.nlu.annotationSets.UpdateNLUAnnotationSetAnnotationsRequest} updateNLUAnnotationSetAnnotationsRequest Payload sent to the update NLU annotation set API.
             */
            SkillManagementServiceClient.prototype.updateAnnotationsForNLUAnnotationSetsV1 = function (skillId, annotationId, contentType, updateNLUAnnotationSetAnnotationsRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callUpdateAnnotationsForNLUAnnotationSetsV1(skillId, annotationId, contentType, updateNLUAnnotationSetAnnotationsRequest)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * API which deletes the NLU annotation set. Developers cannot get/list the deleted annotation set.
             * @param {string} skillId The skill ID.
             * @param {string} annotationId Identifier of the NLU annotation set.
             */
            SkillManagementServiceClient.prototype.callDeletePropertiesForNLUAnnotationSetsV1 = function (skillId, annotationId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callDeletePropertiesForNLUAnnotationSetsV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'annotationId' is not null or undefined
                                if (annotationId == null) {
                                    throw new Error("Required parameter annotationId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('annotationId', annotationId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/nluAnnotationSets/{annotationId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "NLU annotation set exists and is deleted successfully.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("DELETE", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * API which deletes the NLU annotation set. Developers cannot get/list the deleted annotation set.
             * @param {string} skillId The skill ID.
             * @param {string} annotationId Identifier of the NLU annotation set.
             */
            SkillManagementServiceClient.prototype.deletePropertiesForNLUAnnotationSetsV1 = function (skillId, annotationId) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callDeletePropertiesForNLUAnnotationSetsV1(skillId, annotationId)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Return the properties for an NLU annotation set.
             * @param {string} skillId The skill ID.
             * @param {string} annotationId Identifier of the NLU annotation set.
             */
            SkillManagementServiceClient.prototype.callGetPropertiesForNLUAnnotationSetsV1 = function (skillId, annotationId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetPropertiesForNLUAnnotationSetsV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'annotationId' is not null or undefined
                                if (annotationId == null) {
                                    throw new Error("Required parameter annotationId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('annotationId', annotationId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/nluAnnotationSets/{annotationId}/properties";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "The NLU annotation set exists.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Return the properties for an NLU annotation set.
             * @param {string} skillId The skill ID.
             * @param {string} annotationId Identifier of the NLU annotation set.
             */
            SkillManagementServiceClient.prototype.getPropertiesForNLUAnnotationSetsV1 = function (skillId, annotationId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetPropertiesForNLUAnnotationSetsV1(skillId, annotationId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * API which updates the NLU annotation set properties. Currently, the only data can be updated is annotation set name.
             * @param {string} skillId The skill ID.
             * @param {string} annotationId Identifier of the NLU annotation set.
             * @param {v1.skill.nlu.annotationSets.UpdateNLUAnnotationSetPropertiesRequest} updateNLUAnnotationSetPropertiesRequest Payload sent to the update NLU annotation set properties API.
             */
            SkillManagementServiceClient.prototype.callUpdatePropertiesForNLUAnnotationSetsV1 = function (skillId, annotationId, updateNLUAnnotationSetPropertiesRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callUpdatePropertiesForNLUAnnotationSetsV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'annotationId' is not null or undefined
                                if (annotationId == null) {
                                    throw new Error("Required parameter annotationId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'updateNLUAnnotationSetPropertiesRequest' is not null or undefined
                                if (updateNLUAnnotationSetPropertiesRequest == null) {
                                    throw new Error("Required parameter updateNLUAnnotationSetPropertiesRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('annotationId', annotationId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/nluAnnotationSets/{annotationId}/properties";
                                errorDefinitions = new Map();
                                errorDefinitions.set(201, "NLU annotation set exists and properties are updated successfully.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("PUT", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, updateNLUAnnotationSetPropertiesRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * API which updates the NLU annotation set properties. Currently, the only data can be updated is annotation set name.
             * @param {string} skillId The skill ID.
             * @param {string} annotationId Identifier of the NLU annotation set.
             * @param {v1.skill.nlu.annotationSets.UpdateNLUAnnotationSetPropertiesRequest} updateNLUAnnotationSetPropertiesRequest Payload sent to the update NLU annotation set properties API.
             */
            SkillManagementServiceClient.prototype.updatePropertiesForNLUAnnotationSetsV1 = function (skillId, annotationId, updateNLUAnnotationSetPropertiesRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callUpdatePropertiesForNLUAnnotationSetsV1(skillId, annotationId, updateNLUAnnotationSetPropertiesRequest)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * API which requests all the NLU annotation sets for a skill. Returns the annotationId and properties for each NLU annotation set. Developers can filter the results using locale. Supports paging of results.
             * @param {string} skillId The skill ID.
             * @param {string} locale filter to NLU annotation set created using this locale
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. Defaults to 10. If more results are present, the response will contain a nextToken and a _link.next href.
             */
            SkillManagementServiceClient.prototype.callListNLUAnnotationSetsV1 = function (skillId, locale, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, localeValues, nextTokenValues, maxResultsValues, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callListNLUAnnotationSetsV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (locale != null) {
                                    localeValues = Array.isArray(locale) ? locale : [locale];
                                    localeValues.forEach(function (val) { return queryParams.push({ key: 'locale', value: val }); });
                                }
                                if (nextToken != null) {
                                    nextTokenValues = Array.isArray(nextToken) ? nextToken : [nextToken];
                                    nextTokenValues.forEach(function (val) { return queryParams.push({ key: 'nextToken', value: val }); });
                                }
                                if (maxResults != null) {
                                    maxResultsValues = Array.isArray(maxResults) ? maxResults : [maxResults];
                                    maxResultsValues.forEach(function (val) { return queryParams.push({ key: 'maxResults', value: val.toString() }); });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/nluAnnotationSets";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "NLU annotation sets are returned.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * API which requests all the NLU annotation sets for a skill. Returns the annotationId and properties for each NLU annotation set. Developers can filter the results using locale. Supports paging of results.
             * @param {string} skillId The skill ID.
             * @param {string} locale filter to NLU annotation set created using this locale
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. Defaults to 10. If more results are present, the response will contain a nextToken and a _link.next href.
             */
            SkillManagementServiceClient.prototype.listNLUAnnotationSetsV1 = function (skillId, locale, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callListNLUAnnotationSetsV1(skillId, locale, nextToken, maxResults)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * This is an API that creates a new NLU annotation set with properties and returns the annotationId.
             * @param {string} skillId The skill ID.
             * @param {v1.skill.nlu.annotationSets.CreateNLUAnnotationSetRequest} createNLUAnnotationSetRequest Payload sent to the create NLU annotation set API.
             */
            SkillManagementServiceClient.prototype.callCreateNLUAnnotationSetV1 = function (skillId, createNLUAnnotationSetRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callCreateNLUAnnotationSetV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'createNLUAnnotationSetRequest' is not null or undefined
                                if (createNLUAnnotationSetRequest == null) {
                                    throw new Error("Required parameter createNLUAnnotationSetRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/nluAnnotationSets";
                                errorDefinitions = new Map();
                                errorDefinitions.set(201, "NLU annotation set created successfully.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, createNLUAnnotationSetRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * This is an API that creates a new NLU annotation set with properties and returns the annotationId.
             * @param {string} skillId The skill ID.
             * @param {v1.skill.nlu.annotationSets.CreateNLUAnnotationSetRequest} createNLUAnnotationSetRequest Payload sent to the create NLU annotation set API.
             */
            SkillManagementServiceClient.prototype.createNLUAnnotationSetV1 = function (skillId, createNLUAnnotationSetRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callCreateNLUAnnotationSetV1(skillId, createNLUAnnotationSetRequest)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * API which requests top level information about the evaluation like the current state of the job, status of the evaluation (if complete). Also returns data used to start the job, like the number of test cases, stage, locale, and start time. This should be considered the 'cheap' operation while getResultForNLUEvaluations is 'expensive'.
             * @param {string} skillId The skill ID.
             * @param {string} evaluationId Identifier of the evaluation.
             */
            SkillManagementServiceClient.prototype.callGetNLUEvaluationV1 = function (skillId, evaluationId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetNLUEvaluationV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'evaluationId' is not null or undefined
                                if (evaluationId == null) {
                                    throw new Error("Required parameter evaluationId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('evaluationId', evaluationId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/nluEvaluations/{evaluationId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Evaluation exists and its status is queryable.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * API which requests top level information about the evaluation like the current state of the job, status of the evaluation (if complete). Also returns data used to start the job, like the number of test cases, stage, locale, and start time. This should be considered the 'cheap' operation while getResultForNLUEvaluations is 'expensive'.
             * @param {string} skillId The skill ID.
             * @param {string} evaluationId Identifier of the evaluation.
             */
            SkillManagementServiceClient.prototype.getNLUEvaluationV1 = function (skillId, evaluationId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetNLUEvaluationV1(skillId, evaluationId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Paginated API which returns the test case results of an evaluation. This should be considered the 'expensive' operation while getNluEvaluation is 'cheap'.
             * @param {string} skillId The skill ID.
             * @param {string} evaluationId Identifier of the evaluation.
             * @param {string} sortField
             * @param {string} testCaseStatus only returns test cases with this status
             * @param {string} actualIntentName only returns test cases with intents which resolve to this intent
             * @param {string} expectedIntentName only returns test cases with intents which are expected to be this intent
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. Defaults to 1000. If more results are present, the response will contain a nextToken and a _link.next href.
             */
            SkillManagementServiceClient.prototype.callGetResultForNLUEvaluationsV1 = function (skillId, evaluationId, sortField, testCaseStatus, actualIntentName, expectedIntentName, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, sortFieldValues, testCaseStatusValues, actualIntentNameValues, expectedIntentNameValues, nextTokenValues, maxResultsValues, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetResultForNLUEvaluationsV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'evaluationId' is not null or undefined
                                if (evaluationId == null) {
                                    throw new Error("Required parameter evaluationId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (sortField != null) {
                                    sortFieldValues = Array.isArray(sortField) ? sortField : [sortField];
                                    sortFieldValues.forEach(function (val) { return queryParams.push({ key: 'sort.field', value: val }); });
                                }
                                if (testCaseStatus != null) {
                                    testCaseStatusValues = Array.isArray(testCaseStatus) ? testCaseStatus : [testCaseStatus];
                                    testCaseStatusValues.forEach(function (val) { return queryParams.push({ key: 'testCaseStatus', value: val }); });
                                }
                                if (actualIntentName != null) {
                                    actualIntentNameValues = Array.isArray(actualIntentName) ? actualIntentName : [actualIntentName];
                                    actualIntentNameValues.forEach(function (val) { return queryParams.push({ key: 'actualIntentName', value: val }); });
                                }
                                if (expectedIntentName != null) {
                                    expectedIntentNameValues = Array.isArray(expectedIntentName) ? expectedIntentName : [expectedIntentName];
                                    expectedIntentNameValues.forEach(function (val) { return queryParams.push({ key: 'expectedIntentName', value: val }); });
                                }
                                if (nextToken != null) {
                                    nextTokenValues = Array.isArray(nextToken) ? nextToken : [nextToken];
                                    nextTokenValues.forEach(function (val) { return queryParams.push({ key: 'nextToken', value: val }); });
                                }
                                if (maxResults != null) {
                                    maxResultsValues = Array.isArray(maxResults) ? maxResults : [maxResults];
                                    maxResultsValues.forEach(function (val) { return queryParams.push({ key: 'maxResults', value: val.toString() }); });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('evaluationId', evaluationId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/nluEvaluations/{evaluationId}/results";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Evaluation exists and its status is queryable.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Paginated API which returns the test case results of an evaluation. This should be considered the 'expensive' operation while getNluEvaluation is 'cheap'.
             * @param {string} skillId The skill ID.
             * @param {string} evaluationId Identifier of the evaluation.
             * @param {string} sortField
             * @param {string} testCaseStatus only returns test cases with this status
             * @param {string} actualIntentName only returns test cases with intents which resolve to this intent
             * @param {string} expectedIntentName only returns test cases with intents which are expected to be this intent
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. Defaults to 1000. If more results are present, the response will contain a nextToken and a _link.next href.
             */
            SkillManagementServiceClient.prototype.getResultForNLUEvaluationsV1 = function (skillId, evaluationId, sortField, testCaseStatus, actualIntentName, expectedIntentName, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetResultForNLUEvaluationsV1(skillId, evaluationId, sortField, testCaseStatus, actualIntentName, expectedIntentName, nextToken, maxResults)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * API which requests recently run nlu evaluations started by a vendor for a skill. Returns the evaluation id and some of the parameters used to start the evaluation. Developers can filter the results using locale and stage. Supports paging of results.
             * @param {string} skillId The skill ID.
             * @param {string} locale filter to evaluations started using this locale
             * @param {string} stage filter to evaluations started using this stage
             * @param {string} annotationId filter to evaluations started using this annotationId
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. Defaults to 10. If more results are present, the response will contain a nextToken and a _link.next href.
             */
            SkillManagementServiceClient.prototype.callListNLUEvaluationsV1 = function (skillId, locale, stage, annotationId, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, localeValues, stageValues, annotationIdValues, nextTokenValues, maxResultsValues, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callListNLUEvaluationsV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (locale != null) {
                                    localeValues = Array.isArray(locale) ? locale : [locale];
                                    localeValues.forEach(function (val) { return queryParams.push({ key: 'locale', value: val }); });
                                }
                                if (stage != null) {
                                    stageValues = Array.isArray(stage) ? stage : [stage];
                                    stageValues.forEach(function (val) { return queryParams.push({ key: 'stage', value: val }); });
                                }
                                if (annotationId != null) {
                                    annotationIdValues = Array.isArray(annotationId) ? annotationId : [annotationId];
                                    annotationIdValues.forEach(function (val) { return queryParams.push({ key: 'annotationId', value: val }); });
                                }
                                if (nextToken != null) {
                                    nextTokenValues = Array.isArray(nextToken) ? nextToken : [nextToken];
                                    nextTokenValues.forEach(function (val) { return queryParams.push({ key: 'nextToken', value: val }); });
                                }
                                if (maxResults != null) {
                                    maxResultsValues = Array.isArray(maxResults) ? maxResults : [maxResults];
                                    maxResultsValues.forEach(function (val) { return queryParams.push({ key: 'maxResults', value: val.toString() }); });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/nluEvaluations";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Evaluations are returned.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * API which requests recently run nlu evaluations started by a vendor for a skill. Returns the evaluation id and some of the parameters used to start the evaluation. Developers can filter the results using locale and stage. Supports paging of results.
             * @param {string} skillId The skill ID.
             * @param {string} locale filter to evaluations started using this locale
             * @param {string} stage filter to evaluations started using this stage
             * @param {string} annotationId filter to evaluations started using this annotationId
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. Defaults to 10. If more results are present, the response will contain a nextToken and a _link.next href.
             */
            SkillManagementServiceClient.prototype.listNLUEvaluationsV1 = function (skillId, locale, stage, annotationId, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callListNLUEvaluationsV1(skillId, locale, stage, annotationId, nextToken, maxResults)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * This is an asynchronous API that starts an evaluation against the NLU model built by the skill's interaction model. The operation outputs an evaluationId which allows the retrieval of the current status of the operation and the results upon completion. This operation is unified, meaning both internal and external skill developers may use it evaluate NLU models.
             * @param {v1.skill.nlu.evaluations.EvaluateNLURequest} evaluateNLURequest Payload sent to the evaluate NLU API.
             * @param {string} skillId The skill ID.
             */
            SkillManagementServiceClient.prototype.callCreateNLUEvaluationsV1 = function (evaluateNLURequest, skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callCreateNLUEvaluationsV1';
                                // verify required parameter 'evaluateNLURequest' is not null or undefined
                                if (evaluateNLURequest == null) {
                                    throw new Error("Required parameter evaluateNLURequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/nluEvaluations";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Evaluation has successfully begun.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, evaluateNLURequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * This is an asynchronous API that starts an evaluation against the NLU model built by the skill's interaction model. The operation outputs an evaluationId which allows the retrieval of the current status of the operation and the results upon completion. This operation is unified, meaning both internal and external skill developers may use it evaluate NLU models.
             * @param {v1.skill.nlu.evaluations.EvaluateNLURequest} evaluateNLURequest Payload sent to the evaluate NLU API.
             * @param {string} skillId The skill ID.
             */
            SkillManagementServiceClient.prototype.createNLUEvaluationsV1 = function (evaluateNLURequest, skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callCreateNLUEvaluationsV1(evaluateNLURequest, skillId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * If the skill is in certified stage, initiate publishing immediately or set a date at which the skill can publish at.
             * @param {string} skillId The skill ID.
             * @param {string} acceptLanguage User&#39;s locale/language in context.
             * @param {v1.skill.publication.PublishSkillRequest} publishSkillRequest Defines the request body for publish skill API.
             */
            SkillManagementServiceClient.prototype.callPublishSkillV1 = function (skillId, acceptLanguage, publishSkillRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callPublishSkillV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'acceptLanguage' is not null or undefined
                                if (acceptLanguage == null) {
                                    throw new Error("Required parameter acceptLanguage was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                headerParams.push({ key: 'Accept-Language', value: acceptLanguage });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/publications";
                                errorDefinitions = new Map();
                                errorDefinitions.set(202, "Successfully processed skill publication request.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, publishSkillRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * If the skill is in certified stage, initiate publishing immediately or set a date at which the skill can publish at.
             * @param {string} skillId The skill ID.
             * @param {string} acceptLanguage User&#39;s locale/language in context.
             * @param {v1.skill.publication.PublishSkillRequest} publishSkillRequest Defines the request body for publish skill API.
             */
            SkillManagementServiceClient.prototype.publishSkillV1 = function (skillId, acceptLanguage, publishSkillRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callPublishSkillV1(skillId, acceptLanguage, publishSkillRequest)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Retrieves the latest skill publishing details of the certified stage of the skill. The publishesAtDate and status of skill publishing.
             * @param {string} skillId The skill ID.
             * @param {string} acceptLanguage User&#39;s locale/language in context.
             */
            SkillManagementServiceClient.prototype.callGetSkillPublicationsV1 = function (skillId, acceptLanguage) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetSkillPublicationsV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'acceptLanguage' is not null or undefined
                                if (acceptLanguage == null) {
                                    throw new Error("Required parameter acceptLanguage was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                headerParams.push({ key: 'Accept-Language', value: acceptLanguage });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/publications/~latest";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Successfully retrieved latest skill publication information.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Retrieves the latest skill publishing details of the certified stage of the skill. The publishesAtDate and status of skill publishing.
             * @param {string} skillId The skill ID.
             * @param {string} acceptLanguage User&#39;s locale/language in context.
             */
            SkillManagementServiceClient.prototype.getSkillPublicationsV1 = function (skillId, acceptLanguage) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetSkillPublicationsV1(skillId, acceptLanguage)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Submit a target skill version to rollback to. Only one rollback or publish operation can be outstanding for a given skillId.
             * @param {string} skillId The skill ID.
             * @param {v1.skill.CreateRollbackRequest} createRollbackRequest defines the request body to create a rollback request
             */
            SkillManagementServiceClient.prototype.callRollbackSkillV1 = function (skillId, createRollbackRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callRollbackSkillV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'createRollbackRequest' is not null or undefined
                                if (createRollbackRequest == null) {
                                    throw new Error("Required parameter createRollbackRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/rollbacks";
                                errorDefinitions = new Map();
                                errorDefinitions.set(201, "Rollback request created; Returns the generated identifier to track the rollback request and returns a URL to track the status in Location header.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(409, "The request could not be completed due to a conflict with the current state of the target resource.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, createRollbackRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Submit a target skill version to rollback to. Only one rollback or publish operation can be outstanding for a given skillId.
             * @param {string} skillId The skill ID.
             * @param {v1.skill.CreateRollbackRequest} createRollbackRequest defines the request body to create a rollback request
             */
            SkillManagementServiceClient.prototype.rollbackSkillV1 = function (skillId, createRollbackRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callRollbackSkillV1(skillId, createRollbackRequest)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Get the rollback status of a skill given an associated rollbackRequestId. Use ~latest in place of rollbackRequestId to get the latest rollback status.
             * @param {string} skillId The skill ID.
             * @param {string} rollbackRequestId Defines the identifier for a rollback request. If set to ~latest, request returns the status of the latest rollback request.
             */
            SkillManagementServiceClient.prototype.callGetRollbackForSkillV1 = function (skillId, rollbackRequestId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetRollbackForSkillV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'rollbackRequestId' is not null or undefined
                                if (rollbackRequestId == null) {
                                    throw new Error("Required parameter rollbackRequestId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('rollbackRequestId', rollbackRequestId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/rollbacks/{rollbackRequestId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns the rollback status for a given skillId and rollbackRequestId. Returns the latest rollback status if ~latest is used in place of rollbackRequestId.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Get the rollback status of a skill given an associated rollbackRequestId. Use ~latest in place of rollbackRequestId to get the latest rollback status.
             * @param {string} skillId The skill ID.
             * @param {string} rollbackRequestId Defines the identifier for a rollback request. If set to ~latest, request returns the status of the latest rollback request.
             */
            SkillManagementServiceClient.prototype.getRollbackForSkillV1 = function (skillId, rollbackRequestId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetRollbackForSkillV1(skillId, rollbackRequestId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * This is an asynchronous API that simulates a skill execution in the Alexa eco-system given an utterance text of what a customer would say to Alexa. A successful response will contain a header with the location of the simulation resource. In cases where requests to this API results in an error, the response will contain an error code and a description of the problem. The skill being simulated must be in development stage, and it must also belong to and be enabled by the user of this API. Concurrent requests per user is currently not supported.
             * @param {string} skillId The skill ID.
             * @param {v1.skill.simulations.SimulationsApiRequest} simulationsApiRequest Payload sent to the skill simulation API.
             */
            SkillManagementServiceClient.prototype.callSimulateSkillV1 = function (skillId, simulationsApiRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callSimulateSkillV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'simulationsApiRequest' is not null or undefined
                                if (simulationsApiRequest == null) {
                                    throw new Error("Required parameter simulationsApiRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/simulations";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Skill simulation has successfully began.");
                                errorDefinitions.set(400, "Bad request due to invalid or missing data.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "API user does not have permission to call this API or is currently in a state that does not allow simulation of this skill. ");
                                errorDefinitions.set(404, "The specified skill does not exist.");
                                errorDefinitions.set(409, "This requests conflicts with another one currently being processed. ");
                                errorDefinitions.set(429, "API user has exceeded the permitted request rate.");
                                errorDefinitions.set(500, "Internal service error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, simulationsApiRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * This is an asynchronous API that simulates a skill execution in the Alexa eco-system given an utterance text of what a customer would say to Alexa. A successful response will contain a header with the location of the simulation resource. In cases where requests to this API results in an error, the response will contain an error code and a description of the problem. The skill being simulated must be in development stage, and it must also belong to and be enabled by the user of this API. Concurrent requests per user is currently not supported.
             * @param {string} skillId The skill ID.
             * @param {v1.skill.simulations.SimulationsApiRequest} simulationsApiRequest Payload sent to the skill simulation API.
             */
            SkillManagementServiceClient.prototype.simulateSkillV1 = function (skillId, simulationsApiRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callSimulateSkillV1(skillId, simulationsApiRequest)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * This API gets the result of a previously executed simulation. A successful response will contain the status of the executed simulation. If the simulation successfully completed, the response will also contain information related to skill invocation. In cases where requests to this API results in an error, the response will contain an error code and a description of the problem. In cases where the simulation failed, the response will contain a status attribute indicating that a failure occurred and details about what was sent to the skill endpoint. Note that simulation results are stored for 10 minutes. A request for an expired simulation result will return a 404 HTTP status code.
             * @param {string} skillId The skill ID.
             * @param {string} simulationId Id of the simulation.
             */
            SkillManagementServiceClient.prototype.callGetSkillSimulationV1 = function (skillId, simulationId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetSkillSimulationV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'simulationId' is not null or undefined
                                if (simulationId == null) {
                                    throw new Error("Required parameter simulationId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('simulationId', simulationId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/simulations/{simulationId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Successfully retrieved skill simulation information.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "API user does not have permission or is currently in a state that does not allow calls to this API. ");
                                errorDefinitions.set(404, "The specified skill or simulation does not exist. The error response will contain a description that indicates the specific resource type that was not found. ");
                                errorDefinitions.set(429, "API user has exceeded the permitted request rate.");
                                errorDefinitions.set(500, "Internal service error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * This API gets the result of a previously executed simulation. A successful response will contain the status of the executed simulation. If the simulation successfully completed, the response will also contain information related to skill invocation. In cases where requests to this API results in an error, the response will contain an error code and a description of the problem. In cases where the simulation failed, the response will contain a status attribute indicating that a failure occurred and details about what was sent to the skill endpoint. Note that simulation results are stored for 10 minutes. A request for an expired simulation result will return a 404 HTTP status code.
             * @param {string} skillId The skill ID.
             * @param {string} simulationId Id of the simulation.
             */
            SkillManagementServiceClient.prototype.getSkillSimulationV1 = function (skillId, simulationId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetSkillSimulationV1(skillId, simulationId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Get top level information and status of a Smart Home capability evaluation.
             * @param {string} skillId The skill ID.
             * @param {string} evaluationId A unique ID to identify each Smart Home capability evaluation.
             */
            SkillManagementServiceClient.prototype.callGetSmartHomeCapabilityEvaluationV1 = function (skillId, evaluationId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetSmartHomeCapabilityEvaluationV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'evaluationId' is not null or undefined
                                if (evaluationId == null) {
                                    throw new Error("Required parameter evaluationId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('evaluationId', evaluationId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/smartHome/testing/capabilityEvaluations/{evaluationId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Successfully retrieved the evaluation status.");
                                errorDefinitions.set(400, "Bad Request. Returned when the request payload is malformed or when, at least, one required property is missing or invalid. ");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource. ");
                                errorDefinitions.set(403, "API user does not have permission or is currently in a state that does not allow calls to this API. ");
                                errorDefinitions.set(404, "The specified skill, test plan, or evaluation does not exist. The error response will contain a description that indicates the specific resource type that was not found. ");
                                errorDefinitions.set(429, "Exceeded the permitted request limit. Throttling criteria includes total requests, per API and CustomerId. ");
                                errorDefinitions.set(0, "Internal server error. ");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Get top level information and status of a Smart Home capability evaluation.
             * @param {string} skillId The skill ID.
             * @param {string} evaluationId A unique ID to identify each Smart Home capability evaluation.
             */
            SkillManagementServiceClient.prototype.getSmartHomeCapabilityEvaluationV1 = function (skillId, evaluationId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetSmartHomeCapabilityEvaluationV1(skillId, evaluationId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Get test case results for an evaluation run.
             * @param {string} skillId The skill ID.
             * @param {string} evaluationId A unique ID to identify each Smart Home capability evaluation.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             */
            SkillManagementServiceClient.prototype.callGetSmarthomeCapablityEvaluationResultsV1 = function (skillId, evaluationId, maxResults, nextToken) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, maxResultsValues, nextTokenValues, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetSmarthomeCapablityEvaluationResultsV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'evaluationId' is not null or undefined
                                if (evaluationId == null) {
                                    throw new Error("Required parameter evaluationId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (maxResults != null) {
                                    maxResultsValues = Array.isArray(maxResults) ? maxResults : [maxResults];
                                    maxResultsValues.forEach(function (val) { return queryParams.push({ key: 'maxResults', value: val.toString() }); });
                                }
                                if (nextToken != null) {
                                    nextTokenValues = Array.isArray(nextToken) ? nextToken : [nextToken];
                                    nextTokenValues.forEach(function (val) { return queryParams.push({ key: 'nextToken', value: val }); });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('evaluationId', evaluationId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/smartHome/testing/capabilityEvaluations/{evaluationId}/results";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Successfully retrieved the evaluation result content.");
                                errorDefinitions.set(400, "Bad Request. Returned when the request payload is malformed or when, at least, one required property is missing or invalid. ");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource. ");
                                errorDefinitions.set(403, "API user does not have permission or is currently in a state that does not allow calls to this API. ");
                                errorDefinitions.set(404, "The specified skill, test plan, or evaluation does not exist. The error response will contain a description that indicates the specific resource type that was not found. ");
                                errorDefinitions.set(429, "Exceeded the permitted request limit. Throttling criteria includes total requests, per API and CustomerId. ");
                                errorDefinitions.set(0, "Internal server error. ");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Get test case results for an evaluation run.
             * @param {string} skillId The skill ID.
             * @param {string} evaluationId A unique ID to identify each Smart Home capability evaluation.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             */
            SkillManagementServiceClient.prototype.getSmarthomeCapablityEvaluationResultsV1 = function (skillId, evaluationId, maxResults, nextToken) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetSmarthomeCapablityEvaluationResultsV1(skillId, evaluationId, maxResults, nextToken)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * List Smart Home capability evaluation runs for a skill.
             * @param {string} skillId The skill ID.
             * @param {string} stage The stage of the skill to be used for evaluation. An error will be returned if this skill stage is not enabled on the account used for evaluation.
             * @param {string} startTimestampFrom The begnning of the start time to query evaluation result.
             * @param {string} startTimestampTo The end of the start time to query evaluation result.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             */
            SkillManagementServiceClient.prototype.callListSmarthomeCapabilityEvaluationsV1 = function (skillId, stage, startTimestampFrom, startTimestampTo, maxResults, nextToken) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, stageValues, startTimestampFromValues, startTimestampToValues, maxResultsValues, nextTokenValues, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callListSmarthomeCapabilityEvaluationsV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                stageValues = Array.isArray(stage) ? stage : [stage];
                                stageValues.forEach(function (val) { return queryParams.push({ key: 'stage', value: val }); });
                                if (startTimestampFrom != null) {
                                    startTimestampFromValues = Array.isArray(startTimestampFrom) ? startTimestampFrom : [startTimestampFrom];
                                    startTimestampFromValues.forEach(function (val) { return queryParams.push({ key: 'startTimestampFrom', value: val.toString() }); });
                                }
                                if (startTimestampTo != null) {
                                    startTimestampToValues = Array.isArray(startTimestampTo) ? startTimestampTo : [startTimestampTo];
                                    startTimestampToValues.forEach(function (val) { return queryParams.push({ key: 'startTimestampTo', value: val.toString() }); });
                                }
                                if (maxResults != null) {
                                    maxResultsValues = Array.isArray(maxResults) ? maxResults : [maxResults];
                                    maxResultsValues.forEach(function (val) { return queryParams.push({ key: 'maxResults', value: val.toString() }); });
                                }
                                if (nextToken != null) {
                                    nextTokenValues = Array.isArray(nextToken) ? nextToken : [nextToken];
                                    nextTokenValues.forEach(function (val) { return queryParams.push({ key: 'nextToken', value: val }); });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/smartHome/testing/capabilityEvaluations";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Successfully retrieved the evaluation infomation.");
                                errorDefinitions.set(400, "Bad Request. Returned when the request payload is malformed or when, at least, one required property is missing or invalid. ");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource. ");
                                errorDefinitions.set(403, "API user does not have permission or is currently in a state that does not allow calls to this API. ");
                                errorDefinitions.set(404, "The specified skill, test plan, or evaluation does not exist. The error response will contain a description that indicates the specific resource type that was not found. ");
                                errorDefinitions.set(429, "Exceeded the permitted request limit. Throttling criteria includes total requests, per API and CustomerId. ");
                                errorDefinitions.set(0, "Internal server error. ");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * List Smart Home capability evaluation runs for a skill.
             * @param {string} skillId The skill ID.
             * @param {string} stage The stage of the skill to be used for evaluation. An error will be returned if this skill stage is not enabled on the account used for evaluation.
             * @param {string} startTimestampFrom The begnning of the start time to query evaluation result.
             * @param {string} startTimestampTo The end of the start time to query evaluation result.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             */
            SkillManagementServiceClient.prototype.listSmarthomeCapabilityEvaluationsV1 = function (skillId, stage, startTimestampFrom, startTimestampTo, maxResults, nextToken) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callListSmarthomeCapabilityEvaluationsV1(skillId, stage, startTimestampFrom, startTimestampTo, maxResults, nextToken)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Start a capability evaluation against a Smart Home skill.
             * @param {string} skillId The skill ID.
             * @param {v1.smartHomeEvaluation.EvaluateSHCapabilityRequest} evaluateSHCapabilityPayload Payload sent to start a capability evaluation against a Smart Home skill.
             */
            SkillManagementServiceClient.prototype.callCreateSmarthomeCapabilityEvaluationV1 = function (skillId, evaluateSHCapabilityPayload) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callCreateSmarthomeCapabilityEvaluationV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/smartHome/testing/capabilityEvaluations";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Evaluation has successfully begun.");
                                errorDefinitions.set(400, "Bad Request. Returned when the request payload is malformed or when, at least, one required property is missing or invalid. ");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource. ");
                                errorDefinitions.set(403, "API user does not have permission or is currently in a state that does not allow calls to this API. ");
                                errorDefinitions.set(404, "The specified skill, test plan, or evaluation does not exist. The error response will contain a description that indicates the specific resource type that was not found. ");
                                errorDefinitions.set(409, "A test run is already in progress for the specified endpoint. Please retry after some time. ");
                                errorDefinitions.set(429, "Exceeded the permitted request limit. Throttling criteria includes total requests, per API and CustomerId. ");
                                errorDefinitions.set(0, "Internal server error. ");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, evaluateSHCapabilityPayload, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Start a capability evaluation against a Smart Home skill.
             * @param {string} skillId The skill ID.
             * @param {v1.smartHomeEvaluation.EvaluateSHCapabilityRequest} evaluateSHCapabilityPayload Payload sent to start a capability evaluation against a Smart Home skill.
             */
            SkillManagementServiceClient.prototype.createSmarthomeCapabilityEvaluationV1 = function (skillId, evaluateSHCapabilityPayload) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callCreateSmarthomeCapabilityEvaluationV1(skillId, evaluateSHCapabilityPayload)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * List all the test plan names and ids for a given skill ID.
             * @param {string} skillId The skill ID.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             */
            SkillManagementServiceClient.prototype.callListSmarthomeCapabilityTestPlansV1 = function (skillId, maxResults, nextToken) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, maxResultsValues, nextTokenValues, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callListSmarthomeCapabilityTestPlansV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (maxResults != null) {
                                    maxResultsValues = Array.isArray(maxResults) ? maxResults : [maxResults];
                                    maxResultsValues.forEach(function (val) { return queryParams.push({ key: 'maxResults', value: val.toString() }); });
                                }
                                if (nextToken != null) {
                                    nextTokenValues = Array.isArray(nextToken) ? nextToken : [nextToken];
                                    nextTokenValues.forEach(function (val) { return queryParams.push({ key: 'nextToken', value: val }); });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/smartHome/testing/capabilityTestPlans";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Successfully got the list of test plans.");
                                errorDefinitions.set(400, "Bad Request. Returned when the request payload is malformed or when, at least, one required property is missing or invalid. ");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource. ");
                                errorDefinitions.set(403, "API user does not have permission or is currently in a state that does not allow calls to this API. ");
                                errorDefinitions.set(404, "The specified skill, test plan, or evaluation does not exist. The error response will contain a description that indicates the specific resource type that was not found. ");
                                errorDefinitions.set(429, "Exceeded the permitted request limit. Throttling criteria includes total requests, per API and CustomerId. ");
                                errorDefinitions.set(0, "Internal server error. ");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * List all the test plan names and ids for a given skill ID.
             * @param {string} skillId The skill ID.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             */
            SkillManagementServiceClient.prototype.listSmarthomeCapabilityTestPlansV1 = function (skillId, maxResults, nextToken) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callListSmarthomeCapabilityTestPlansV1(skillId, maxResults, nextToken)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Returns the ssl certificate sets currently associated with this skill. Sets consist of one ssl certificate blob associated with a region as well as the default certificate for the skill.
             * @param {string} skillId The skill ID.
             */
            SkillManagementServiceClient.prototype.callGetSSLCertificatesV1 = function (skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetSSLCertificatesV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/sslCertificateSets/~latest";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Response contains the latest version of the ssl certificates.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Returns the ssl certificate sets currently associated with this skill. Sets consist of one ssl certificate blob associated with a region as well as the default certificate for the skill.
             * @param {string} skillId The skill ID.
             */
            SkillManagementServiceClient.prototype.getSSLCertificatesV1 = function (skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetSSLCertificatesV1(skillId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Updates the ssl certificates associated with this skill.
             * @param {string} skillId The skill ID.
             * @param {v1.skill.SSLCertificatePayload} sslCertificatePayload Defines the input/output of the ssl certificates api for a skill.
             */
            SkillManagementServiceClient.prototype.callSetSSLCertificatesV1 = function (skillId, sslCertificatePayload) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callSetSSLCertificatesV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'sslCertificatePayload' is not null or undefined
                                if (sslCertificatePayload == null) {
                                    throw new Error("Required parameter sslCertificatePayload was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/sslCertificateSets/~latest";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Accepted; Request was successful and get will now result in the new values.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("PUT", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, sslCertificatePayload, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Updates the ssl certificates associated with this skill.
             * @param {string} skillId The skill ID.
             * @param {v1.skill.SSLCertificatePayload} sslCertificatePayload Defines the input/output of the ssl certificates api for a skill.
             */
            SkillManagementServiceClient.prototype.setSSLCertificatesV1 = function (skillId, sslCertificatePayload) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callSetSSLCertificatesV1(skillId, sslCertificatePayload)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Deletes the enablement for given skillId/stage and customerId (retrieved from Auth token).
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             */
            SkillManagementServiceClient.prototype.callDeleteSkillEnablementV1 = function (skillId, stage) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callDeleteSkillEnablementV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stage', stage);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/stages/{stage}/enablement";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "No Content; Confirms that enablement is successfully deleted.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("DELETE", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Deletes the enablement for given skillId/stage and customerId (retrieved from Auth token).
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             */
            SkillManagementServiceClient.prototype.deleteSkillEnablementV1 = function (skillId, stage) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callDeleteSkillEnablementV1(skillId, stage)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Checks whether an enablement exist for given skillId/stage and customerId (retrieved from Auth token)
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             */
            SkillManagementServiceClient.prototype.callGetSkillEnablementStatusV1 = function (skillId, stage) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetSkillEnablementStatusV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stage', stage);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/stages/{stage}/enablement";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "No Content; Confirms that enablement resource exists for given skillId &amp; stage.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Checks whether an enablement exist for given skillId/stage and customerId (retrieved from Auth token)
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             */
            SkillManagementServiceClient.prototype.getSkillEnablementStatusV1 = function (skillId, stage) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetSkillEnablementStatusV1(skillId, stage)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Creates/Updates the enablement for given skillId/stage and customerId (retrieved from Auth token)
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             */
            SkillManagementServiceClient.prototype.callSetSkillEnablementV1 = function (skillId, stage) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callSetSkillEnablementV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stage', stage);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/stages/{stage}/enablement";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "No Content; Confirms that enablement is successfully created/updated.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(409, "The request could not be completed due to a conflict with the current state of the target resource.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("PUT", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Creates/Updates the enablement for given skillId/stage and customerId (retrieved from Auth token)
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             */
            SkillManagementServiceClient.prototype.setSkillEnablementV1 = function (skillId, stage) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callSetSkillEnablementV1(skillId, stage)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Creates a new export for a skill with given skillId and stage.
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             */
            SkillManagementServiceClient.prototype.callCreateExportRequestForSkillV1 = function (skillId, stage) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callCreateExportRequestForSkillV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stage', stage);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/stages/{stage}/exports";
                                errorDefinitions = new Map();
                                errorDefinitions.set(202, "Accepted.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(409, "The request could not be completed due to a conflict with the current state of the target resource.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Creates a new export for a skill with given skillId and stage.
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             */
            SkillManagementServiceClient.prototype.createExportRequestForSkillV1 = function (skillId, stage) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callCreateExportRequestForSkillV1(skillId, stage)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Get the list of in-skill products for the skillId.
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             */
            SkillManagementServiceClient.prototype.callGetIspListForSkillIdV1 = function (skillId, stage, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, nextTokenValues, maxResultsValues, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetIspListForSkillIdV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (nextToken != null) {
                                    nextTokenValues = Array.isArray(nextToken) ? nextToken : [nextToken];
                                    nextTokenValues.forEach(function (val) { return queryParams.push({ key: 'nextToken', value: val }); });
                                }
                                if (maxResults != null) {
                                    maxResultsValues = Array.isArray(maxResults) ? maxResults : [maxResults];
                                    maxResultsValues.forEach(function (val) { return queryParams.push({ key: 'maxResults', value: val.toString() }); });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stage', stage);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/stages/{stage}/inSkillProducts";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Response contains list of in-skill products for the specified skillId and stage.");
                                errorDefinitions.set(400, "Bad request. Returned when a required parameter is not present, badly formatted. ");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "Requested resource not found.");
                                errorDefinitions.set(429, "Too many requests received.");
                                errorDefinitions.set(500, "Internal Server Error");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Get the list of in-skill products for the skillId.
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             */
            SkillManagementServiceClient.prototype.getIspListForSkillIdV1 = function (skillId, stage, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetIspListForSkillIdV1(skillId, stage, nextToken, maxResults)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * This is a synchronous API that profiles an utterance against interaction model.
             * @param {v1.skill.evaluations.ProfileNluRequest} profileNluRequest Payload sent to the profile nlu API.
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             * @param {string} locale The locale for the model requested e.g. en-GB, en-US, de-DE.
             */
            SkillManagementServiceClient.prototype.callProfileNluV1 = function (profileNluRequest, skillId, stage, locale) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callProfileNluV1';
                                // verify required parameter 'profileNluRequest' is not null or undefined
                                if (profileNluRequest == null) {
                                    throw new Error("Required parameter profileNluRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'locale' is not null or undefined
                                if (locale == null) {
                                    throw new Error("Required parameter locale was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stage', stage);
                                pathParams.set('locale', locale);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/stages/{stage}/interactionModel/locales/{locale}/profileNlu";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Profiled utterance against interaction model and returned nlu response successfully.");
                                errorDefinitions.set(400, "Bad request due to invalid or missing data.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(409, "This requests conflicts with another one currently being processed. ");
                                errorDefinitions.set(429, "API user has exceeded the permitted request rate.");
                                errorDefinitions.set(500, "Internal service error.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, profileNluRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * This is a synchronous API that profiles an utterance against interaction model.
             * @param {v1.skill.evaluations.ProfileNluRequest} profileNluRequest Payload sent to the profile nlu API.
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             * @param {string} locale The locale for the model requested e.g. en-GB, en-US, de-DE.
             */
            SkillManagementServiceClient.prototype.profileNluV1 = function (profileNluRequest, skillId, stage, locale) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callProfileNluV1(profileNluRequest, skillId, stage, locale)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * This API returns the job status of conflict detection job for a specified interaction model.
             * @param {string} skillId The skill ID.
             * @param {string} locale The locale for the model requested e.g. en-GB, en-US, de-DE.
             * @param {string} stage Stage of the interaction model.
             * @param {string} version Version of interaction model. Use \&quot;~current\&quot; to get the model of the current version.
             */
            SkillManagementServiceClient.prototype.callGetConflictDetectionJobStatusForInteractionModelV1 = function (skillId, locale, stage, version) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetConflictDetectionJobStatusForInteractionModelV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'locale' is not null or undefined
                                if (locale == null) {
                                    throw new Error("Required parameter locale was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'version' is not null or undefined
                                if (version == null) {
                                    throw new Error("Required parameter version was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('locale', locale);
                                pathParams.set('stage', stage);
                                pathParams.set('version', version);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/stages/{stage}/interactionModel/locales/{locale}/versions/{version}/conflictDetectionJobStatus";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Get conflict detection results successfully.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "There is no catalog defined for the catalogId.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * This API returns the job status of conflict detection job for a specified interaction model.
             * @param {string} skillId The skill ID.
             * @param {string} locale The locale for the model requested e.g. en-GB, en-US, de-DE.
             * @param {string} stage Stage of the interaction model.
             * @param {string} version Version of interaction model. Use \&quot;~current\&quot; to get the model of the current version.
             */
            SkillManagementServiceClient.prototype.getConflictDetectionJobStatusForInteractionModelV1 = function (skillId, locale, stage, version) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetConflictDetectionJobStatusForInteractionModelV1(skillId, locale, stage, version)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * This is a paginated API that retrieves results of conflict detection job for a specified interaction model.
             * @param {string} skillId The skill ID.
             * @param {string} locale The locale for the model requested e.g. en-GB, en-US, de-DE.
             * @param {string} stage Stage of the interaction model.
             * @param {string} version Version of interaction model. Use \&quot;~current\&quot; to get the model of the current version.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. Defaults to 100. If more results are present, the response will contain a nextToken and a _link.next href.
             */
            SkillManagementServiceClient.prototype.callGetConflictsForInteractionModelV1 = function (skillId, locale, stage, version, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, nextTokenValues, maxResultsValues, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetConflictsForInteractionModelV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'locale' is not null or undefined
                                if (locale == null) {
                                    throw new Error("Required parameter locale was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'version' is not null or undefined
                                if (version == null) {
                                    throw new Error("Required parameter version was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (nextToken != null) {
                                    nextTokenValues = Array.isArray(nextToken) ? nextToken : [nextToken];
                                    nextTokenValues.forEach(function (val) { return queryParams.push({ key: 'nextToken', value: val }); });
                                }
                                if (maxResults != null) {
                                    maxResultsValues = Array.isArray(maxResults) ? maxResults : [maxResults];
                                    maxResultsValues.forEach(function (val) { return queryParams.push({ key: 'maxResults', value: val.toString() }); });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('locale', locale);
                                pathParams.set('stage', stage);
                                pathParams.set('version', version);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/stages/{stage}/interactionModel/locales/{locale}/versions/{version}/conflicts";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Get conflict detection results sucessfully.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "There is no catalog defined for the catalogId.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * This is a paginated API that retrieves results of conflict detection job for a specified interaction model.
             * @param {string} skillId The skill ID.
             * @param {string} locale The locale for the model requested e.g. en-GB, en-US, de-DE.
             * @param {string} stage Stage of the interaction model.
             * @param {string} version Version of interaction model. Use \&quot;~current\&quot; to get the model of the current version.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. Defaults to 100. If more results are present, the response will contain a nextToken and a _link.next href.
             */
            SkillManagementServiceClient.prototype.getConflictsForInteractionModelV1 = function (skillId, locale, stage, version, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetConflictsForInteractionModelV1(skillId, locale, stage, version, nextToken, maxResults)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * List private distribution accounts.
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             */
            SkillManagementServiceClient.prototype.callListPrivateDistributionAccountsV1 = function (skillId, stage, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, nextTokenValues, maxResultsValues, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callListPrivateDistributionAccountsV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (nextToken != null) {
                                    nextTokenValues = Array.isArray(nextToken) ? nextToken : [nextToken];
                                    nextTokenValues.forEach(function (val) { return queryParams.push({ key: 'nextToken', value: val }); });
                                }
                                if (maxResults != null) {
                                    maxResultsValues = Array.isArray(maxResults) ? maxResults : [maxResults];
                                    maxResultsValues.forEach(function (val) { return queryParams.push({ key: 'maxResults', value: val.toString() }); });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stage', stage);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/stages/{stage}/privateDistributionAccounts";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns list of private distribution accounts on success.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * List private distribution accounts.
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             */
            SkillManagementServiceClient.prototype.listPrivateDistributionAccountsV1 = function (skillId, stage, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callListPrivateDistributionAccountsV1(skillId, stage, nextToken, maxResults)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Remove an id from the private distribution accounts.
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             * @param {string} id ARN that a skill can be privately distributed to.
             */
            SkillManagementServiceClient.prototype.callDeletePrivateDistributionAccountIdV1 = function (skillId, stage, id) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callDeletePrivateDistributionAccountIdV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'id' is not null or undefined
                                if (id == null) {
                                    throw new Error("Required parameter id was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stage', stage);
                                pathParams.set('id', id);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/stages/{stage}/privateDistributionAccounts/{id}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Success.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("DELETE", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Remove an id from the private distribution accounts.
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             * @param {string} id ARN that a skill can be privately distributed to.
             */
            SkillManagementServiceClient.prototype.deletePrivateDistributionAccountIdV1 = function (skillId, stage, id) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callDeletePrivateDistributionAccountIdV1(skillId, stage, id)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Add an id to the private distribution accounts.
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             * @param {string} id ARN that a skill can be privately distributed to.
             */
            SkillManagementServiceClient.prototype.callSetPrivateDistributionAccountIdV1 = function (skillId, stage, id) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callSetPrivateDistributionAccountIdV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'id' is not null or undefined
                                if (id == null) {
                                    throw new Error("Required parameter id was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stage', stage);
                                pathParams.set('id', id);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/stages/{stage}/privateDistributionAccounts/{id}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Success.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("PUT", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Add an id to the private distribution accounts.
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             * @param {string} id ARN that a skill can be privately distributed to.
             */
            SkillManagementServiceClient.prototype.setPrivateDistributionAccountIdV1 = function (skillId, stage, id) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callSetPrivateDistributionAccountIdV1(skillId, stage, id)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Delete AccountLinking information of a skill for the given stage.
             * @param {string} skillId The skill ID.
             * @param {string} stageV2 Stages of a skill including the new certified stage. * &#x60;development&#x60; - skills which are currently in development corresponds to this stage. * &#x60;certified&#x60; -  skills which have completed certification and ready for publishing corresponds to this stage. * &#x60;live&#x60; - skills which are currently live corresponds to this stage.
             */
            SkillManagementServiceClient.prototype.callDeleteAccountLinkingInfoV1 = function (skillId, stageV2) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callDeleteAccountLinkingInfoV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stageV2' is not null or undefined
                                if (stageV2 == null) {
                                    throw new Error("Required parameter stageV2 was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stageV2', stageV2);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/stages/{stageV2}/accountLinkingClient";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Success. No content.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The specified skill/stage/accountLinkingClient doesn&#39;t exist.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("DELETE", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Delete AccountLinking information of a skill for the given stage.
             * @param {string} skillId The skill ID.
             * @param {string} stageV2 Stages of a skill including the new certified stage. * &#x60;development&#x60; - skills which are currently in development corresponds to this stage. * &#x60;certified&#x60; -  skills which have completed certification and ready for publishing corresponds to this stage. * &#x60;live&#x60; - skills which are currently live corresponds to this stage.
             */
            SkillManagementServiceClient.prototype.deleteAccountLinkingInfoV1 = function (skillId, stageV2) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callDeleteAccountLinkingInfoV1(skillId, stageV2)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Get AccountLinking information for the skill.
             * @param {string} skillId The skill ID.
             * @param {string} stageV2 Stages of a skill including the new certified stage. * &#x60;development&#x60; - skills which are currently in development corresponds to this stage. * &#x60;certified&#x60; -  skills which have completed certification and ready for publishing corresponds to this stage. * &#x60;live&#x60; - skills which are currently live corresponds to this stage.
             */
            SkillManagementServiceClient.prototype.callGetAccountLinkingInfoV1 = function (skillId, stageV2) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetAccountLinkingInfoV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stageV2' is not null or undefined
                                if (stageV2 == null) {
                                    throw new Error("Required parameter stageV2 was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stageV2', stageV2);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/stages/{stageV2}/accountLinkingClient";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns AccountLinking response of the skill.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Get AccountLinking information for the skill.
             * @param {string} skillId The skill ID.
             * @param {string} stageV2 Stages of a skill including the new certified stage. * &#x60;development&#x60; - skills which are currently in development corresponds to this stage. * &#x60;certified&#x60; -  skills which have completed certification and ready for publishing corresponds to this stage. * &#x60;live&#x60; - skills which are currently live corresponds to this stage.
             */
            SkillManagementServiceClient.prototype.getAccountLinkingInfoV1 = function (skillId, stageV2) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetAccountLinkingInfoV1(skillId, stageV2)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Create AccountLinking information for the skill.
             * @param {string} skillId The skill ID.
             * @param {string} stageV2 Stages of a skill including the new certified stage. * &#x60;development&#x60; - skills which are currently in development corresponds to this stage. * &#x60;certified&#x60; -  skills which have completed certification and ready for publishing corresponds to this stage. * &#x60;live&#x60; - skills which are currently live corresponds to this stage.
             * @param {v1.skill.accountLinking.AccountLinkingRequest} accountLinkingRequest The fields required to create accountLinking partner.
             * @param {string} ifMatch Request header that specified an entity tag. The server will update the resource only if the eTag matches with the resource&#39;s current eTag.
             */
            SkillManagementServiceClient.prototype.callUpdateAccountLinkingInfoV1 = function (skillId, stageV2, accountLinkingRequest, ifMatch) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callUpdateAccountLinkingInfoV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stageV2' is not null or undefined
                                if (stageV2 == null) {
                                    throw new Error("Required parameter stageV2 was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'accountLinkingRequest' is not null or undefined
                                if (accountLinkingRequest == null) {
                                    throw new Error("Required parameter accountLinkingRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (ifMatch != null) {
                                    headerParams.push({ key: 'If-Match', value: ifMatch });
                                }
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stageV2', stageV2);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/stages/{stageV2}/accountLinkingClient";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Success");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error e.g. Authorization Url is invalid.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(412, "Precondition failed.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("PUT", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, accountLinkingRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Create AccountLinking information for the skill.
             * @param {string} skillId The skill ID.
             * @param {string} stageV2 Stages of a skill including the new certified stage. * &#x60;development&#x60; - skills which are currently in development corresponds to this stage. * &#x60;certified&#x60; -  skills which have completed certification and ready for publishing corresponds to this stage. * &#x60;live&#x60; - skills which are currently live corresponds to this stage.
             * @param {v1.skill.accountLinking.AccountLinkingRequest} accountLinkingRequest The fields required to create accountLinking partner.
             * @param {string} ifMatch Request header that specified an entity tag. The server will update the resource only if the eTag matches with the resource&#39;s current eTag.
             */
            SkillManagementServiceClient.prototype.updateAccountLinkingInfoV1 = function (skillId, stageV2, accountLinkingRequest, ifMatch) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callUpdateAccountLinkingInfoV1(skillId, stageV2, accountLinkingRequest, ifMatch)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Creates a new clone locale workflow for a skill with given skillId, source locale, and target locales. In a single workflow, a locale can be cloned to multiple target locales. However, only one such workflow can be started at any time.
             * @param {string} skillId The skill ID.
             * @param {string} stageV2 Stages of a skill on which locales can be cloned. Currently only &#x60;development&#x60; stage is supported. * &#x60;development&#x60; - skills which are currently in development corresponds to this stage.
             * @param {v1.skill.CloneLocaleRequest} cloneLocaleRequest Defines the request body for the cloneLocale API.
             */
            SkillManagementServiceClient.prototype.callCloneLocaleV1 = function (skillId, stageV2, cloneLocaleRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callCloneLocaleV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stageV2' is not null or undefined
                                if (stageV2 == null) {
                                    throw new Error("Required parameter stageV2 was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'cloneLocaleRequest' is not null or undefined
                                if (cloneLocaleRequest == null) {
                                    throw new Error("Required parameter cloneLocaleRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stageV2', stageV2);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/stages/{stageV2}/cloneLocale";
                                errorDefinitions = new Map();
                                errorDefinitions.set(202, "Accepted.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(409, "The request could not be completed due to a conflict with the current state of the target resource.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, cloneLocaleRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Creates a new clone locale workflow for a skill with given skillId, source locale, and target locales. In a single workflow, a locale can be cloned to multiple target locales. However, only one such workflow can be started at any time.
             * @param {string} skillId The skill ID.
             * @param {string} stageV2 Stages of a skill on which locales can be cloned. Currently only &#x60;development&#x60; stage is supported. * &#x60;development&#x60; - skills which are currently in development corresponds to this stage.
             * @param {v1.skill.CloneLocaleRequest} cloneLocaleRequest Defines the request body for the cloneLocale API.
             */
            SkillManagementServiceClient.prototype.cloneLocaleV1 = function (skillId, stageV2, cloneLocaleRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callCloneLocaleV1(skillId, stageV2, cloneLocaleRequest)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Returns the status of a clone locale workflow associated with the unique identifier of cloneLocaleRequestId.
             * @param {string} skillId The skill ID.
             * @param {string} stageV2 Stages of a skill on which locales can be cloned. Currently only &#x60;development&#x60; stage is supported. * &#x60;development&#x60; - skills which are currently in development corresponds to this stage.
             * @param {string} cloneLocaleRequestId Defines the identifier for a clone locale workflow. If set to ~latest, request returns the status of the latest clone locale workflow.
             */
            SkillManagementServiceClient.prototype.callGetCloneLocaleStatusV1 = function (skillId, stageV2, cloneLocaleRequestId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetCloneLocaleStatusV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stageV2' is not null or undefined
                                if (stageV2 == null) {
                                    throw new Error("Required parameter stageV2 was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'cloneLocaleRequestId' is not null or undefined
                                if (cloneLocaleRequestId == null) {
                                    throw new Error("Required parameter cloneLocaleRequestId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stageV2', stageV2);
                                pathParams.set('cloneLocaleRequestId', cloneLocaleRequestId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/stages/{stageV2}/cloneLocaleRequests/{cloneLocaleRequestId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "OK.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Returns the status of a clone locale workflow associated with the unique identifier of cloneLocaleRequestId.
             * @param {string} skillId The skill ID.
             * @param {string} stageV2 Stages of a skill on which locales can be cloned. Currently only &#x60;development&#x60; stage is supported. * &#x60;development&#x60; - skills which are currently in development corresponds to this stage.
             * @param {string} cloneLocaleRequestId Defines the identifier for a clone locale workflow. If set to ~latest, request returns the status of the latest clone locale workflow.
             */
            SkillManagementServiceClient.prototype.getCloneLocaleStatusV1 = function (skillId, stageV2, cloneLocaleRequestId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetCloneLocaleStatusV1(skillId, stageV2, cloneLocaleRequestId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Gets the `InteractionModel` for the skill in the given stage. The path params **skillId**, **stage** and **locale** are required.
             * @param {string} skillId The skill ID.
             * @param {string} stageV2 Stages of a skill including the new certified stage. * &#x60;development&#x60; - skills which are currently in development corresponds to this stage. * &#x60;certified&#x60; -  skills which have completed certification and ready for publishing corresponds to this stage. * &#x60;live&#x60; - skills which are currently live corresponds to this stage.
             * @param {string} locale The locale for the model requested e.g. en-GB, en-US, de-DE.
             */
            SkillManagementServiceClient.prototype.callGetInteractionModelV1 = function (skillId, stageV2, locale) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetInteractionModelV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stageV2' is not null or undefined
                                if (stageV2 == null) {
                                    throw new Error("Required parameter stageV2 was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'locale' is not null or undefined
                                if (locale == null) {
                                    throw new Error("Required parameter locale was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stageV2', stageV2);
                                pathParams.set('locale', locale);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/stages/{stageV2}/interactionModel/locales/{locale}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns interaction model object on success.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The specified skill doesn&#39;t exist or there is no model defined for the locale.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Gets the `InteractionModel` for the skill in the given stage. The path params **skillId**, **stage** and **locale** are required.
             * @param {string} skillId The skill ID.
             * @param {string} stageV2 Stages of a skill including the new certified stage. * &#x60;development&#x60; - skills which are currently in development corresponds to this stage. * &#x60;certified&#x60; -  skills which have completed certification and ready for publishing corresponds to this stage. * &#x60;live&#x60; - skills which are currently live corresponds to this stage.
             * @param {string} locale The locale for the model requested e.g. en-GB, en-US, de-DE.
             */
            SkillManagementServiceClient.prototype.getInteractionModelV1 = function (skillId, stageV2, locale) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetInteractionModelV1(skillId, stageV2, locale)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Get the latest metadata for the interaction model resource for the given stage.
             * @param {string} skillId The skill ID.
             * @param {string} stageV2 Stages of a skill including the new certified stage. * &#x60;development&#x60; - skills which are currently in development corresponds to this stage. * &#x60;certified&#x60; -  skills which have completed certification and ready for publishing corresponds to this stage. * &#x60;live&#x60; - skills which are currently live corresponds to this stage.
             * @param {string} locale The locale for the model requested e.g. en-GB, en-US, de-DE.
             */
            SkillManagementServiceClient.prototype.callGetInteractionModelMetadataV1 = function (skillId, stageV2, locale) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetInteractionModelMetadataV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stageV2' is not null or undefined
                                if (stageV2 == null) {
                                    throw new Error("Required parameter stageV2 was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'locale' is not null or undefined
                                if (locale == null) {
                                    throw new Error("Required parameter locale was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stageV2', stageV2);
                                pathParams.set('locale', locale);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/stages/{stageV2}/interactionModel/locales/{locale}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Success. There is no content but returns etag.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The specified skill or stage or locale does not exist");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("HEAD", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Get the latest metadata for the interaction model resource for the given stage.
             * @param {string} skillId The skill ID.
             * @param {string} stageV2 Stages of a skill including the new certified stage. * &#x60;development&#x60; - skills which are currently in development corresponds to this stage. * &#x60;certified&#x60; -  skills which have completed certification and ready for publishing corresponds to this stage. * &#x60;live&#x60; - skills which are currently live corresponds to this stage.
             * @param {string} locale The locale for the model requested e.g. en-GB, en-US, de-DE.
             */
            SkillManagementServiceClient.prototype.getInteractionModelMetadataV1 = function (skillId, stageV2, locale) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetInteractionModelMetadataV1(skillId, stageV2, locale)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Creates an `InteractionModel` for the skill.
             * @param {string} skillId The skill ID.
             * @param {string} stageV2 Stages of a skill including the new certified stage. * &#x60;development&#x60; - skills which are currently in development corresponds to this stage. * &#x60;certified&#x60; -  skills which have completed certification and ready for publishing corresponds to this stage. * &#x60;live&#x60; - skills which are currently live corresponds to this stage.
             * @param {string} locale The locale for the model requested e.g. en-GB, en-US, de-DE.
             * @param {v1.skill.interactionModel.InteractionModelData} interactionModel
             * @param {string} ifMatch Request header that specified an entity tag. The server will update the resource only if the eTag matches with the resource&#39;s current eTag.
             */
            SkillManagementServiceClient.prototype.callSetInteractionModelV1 = function (skillId, stageV2, locale, interactionModel, ifMatch) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callSetInteractionModelV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stageV2' is not null or undefined
                                if (stageV2 == null) {
                                    throw new Error("Required parameter stageV2 was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'locale' is not null or undefined
                                if (locale == null) {
                                    throw new Error("Required parameter locale was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'interactionModel' is not null or undefined
                                if (interactionModel == null) {
                                    throw new Error("Required parameter interactionModel was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (ifMatch != null) {
                                    headerParams.push({ key: 'If-Match', value: ifMatch });
                                }
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stageV2', stageV2);
                                pathParams.set('locale', locale);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/stages/{stageV2}/interactionModel/locales/{locale}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(202, "Returns build status location link on success.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error e.g. the input interaction model is invalid.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The specified skill or stage or locale does not exist.");
                                errorDefinitions.set(412, "Precondition failed.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("PUT", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, interactionModel, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Creates an `InteractionModel` for the skill.
             * @param {string} skillId The skill ID.
             * @param {string} stageV2 Stages of a skill including the new certified stage. * &#x60;development&#x60; - skills which are currently in development corresponds to this stage. * &#x60;certified&#x60; -  skills which have completed certification and ready for publishing corresponds to this stage. * &#x60;live&#x60; - skills which are currently live corresponds to this stage.
             * @param {string} locale The locale for the model requested e.g. en-GB, en-US, de-DE.
             * @param {v1.skill.interactionModel.InteractionModelData} interactionModel
             * @param {string} ifMatch Request header that specified an entity tag. The server will update the resource only if the eTag matches with the resource&#39;s current eTag.
             */
            SkillManagementServiceClient.prototype.setInteractionModelV1 = function (skillId, stageV2, locale, interactionModel, ifMatch) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callSetInteractionModelV1(skillId, stageV2, locale, interactionModel, ifMatch)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Get the list of interactionModel versions of a skill for the vendor.
             * @param {string} skillId The skill ID.
             * @param {string} stageV2 Stages of a skill including the new certified stage. * &#x60;development&#x60; - skills which are currently in development corresponds to this stage. * &#x60;certified&#x60; -  skills which have completed certification and ready for publishing corresponds to this stage. * &#x60;live&#x60; - skills which are currently live corresponds to this stage.
             * @param {string} locale The locale for the model requested e.g. en-GB, en-US, de-DE.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {string} sortDirection Sets the sorting direction of the result items. When set to &#39;asc&#39; these items are returned in ascending order of sortField value and when set to &#39;desc&#39; these items are returned in descending order of sortField value.
             * @param {string} sortField Sets the field on which the sorting would be applied.
             */
            SkillManagementServiceClient.prototype.callListInteractionModelVersionsV1 = function (skillId, stageV2, locale, nextToken, maxResults, sortDirection, sortField) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, nextTokenValues, maxResultsValues, sortDirectionValues, sortFieldValues, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callListInteractionModelVersionsV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stageV2' is not null or undefined
                                if (stageV2 == null) {
                                    throw new Error("Required parameter stageV2 was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'locale' is not null or undefined
                                if (locale == null) {
                                    throw new Error("Required parameter locale was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (nextToken != null) {
                                    nextTokenValues = Array.isArray(nextToken) ? nextToken : [nextToken];
                                    nextTokenValues.forEach(function (val) { return queryParams.push({ key: 'nextToken', value: val }); });
                                }
                                if (maxResults != null) {
                                    maxResultsValues = Array.isArray(maxResults) ? maxResults : [maxResults];
                                    maxResultsValues.forEach(function (val) { return queryParams.push({ key: 'maxResults', value: val.toString() }); });
                                }
                                if (sortDirection != null) {
                                    sortDirectionValues = Array.isArray(sortDirection) ? sortDirection : [sortDirection];
                                    sortDirectionValues.forEach(function (val) { return queryParams.push({ key: 'sortDirection', value: val }); });
                                }
                                if (sortField != null) {
                                    sortFieldValues = Array.isArray(sortField) ? sortField : [sortField];
                                    sortFieldValues.forEach(function (val) { return queryParams.push({ key: 'sortField', value: val }); });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stageV2', stageV2);
                                pathParams.set('locale', locale);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/stages/{stageV2}/interactionModel/locales/{locale}/versions";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns list of interactionModel versions of a skill for the vendor.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error e.g. the input interaction model is invalid.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The specified skill doesn&#39;t exist or there is no model defined for the locale.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Get the list of interactionModel versions of a skill for the vendor.
             * @param {string} skillId The skill ID.
             * @param {string} stageV2 Stages of a skill including the new certified stage. * &#x60;development&#x60; - skills which are currently in development corresponds to this stage. * &#x60;certified&#x60; -  skills which have completed certification and ready for publishing corresponds to this stage. * &#x60;live&#x60; - skills which are currently live corresponds to this stage.
             * @param {string} locale The locale for the model requested e.g. en-GB, en-US, de-DE.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {string} sortDirection Sets the sorting direction of the result items. When set to &#39;asc&#39; these items are returned in ascending order of sortField value and when set to &#39;desc&#39; these items are returned in descending order of sortField value.
             * @param {string} sortField Sets the field on which the sorting would be applied.
             */
            SkillManagementServiceClient.prototype.listInteractionModelVersionsV1 = function (skillId, stageV2, locale, nextToken, maxResults, sortDirection, sortField) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callListInteractionModelVersionsV1(skillId, stageV2, locale, nextToken, maxResults, sortDirection, sortField)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Gets the specified version `InteractionModel` of a skill for the vendor. Use `~current` as version parameter to get the current version model.
             * @param {string} skillId The skill ID.
             * @param {string} stageV2 Stages of a skill including the new certified stage. * &#x60;development&#x60; - skills which are currently in development corresponds to this stage. * &#x60;certified&#x60; -  skills which have completed certification and ready for publishing corresponds to this stage. * &#x60;live&#x60; - skills which are currently live corresponds to this stage.
             * @param {string} locale The locale for the model requested e.g. en-GB, en-US, de-DE.
             * @param {string} version Version for interaction model.
             */
            SkillManagementServiceClient.prototype.callGetInteractionModelVersionV1 = function (skillId, stageV2, locale, version) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetInteractionModelVersionV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stageV2' is not null or undefined
                                if (stageV2 == null) {
                                    throw new Error("Required parameter stageV2 was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'locale' is not null or undefined
                                if (locale == null) {
                                    throw new Error("Required parameter locale was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'version' is not null or undefined
                                if (version == null) {
                                    throw new Error("Required parameter version was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stageV2', stageV2);
                                pathParams.set('locale', locale);
                                pathParams.set('version', version);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/stages/{stageV2}/interactionModel/locales/{locale}/versions/{version}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns interaction model object on success.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error e.g. the input interaction model is invalid.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The specified skill doesn&#39;t exist or there is no model defined for the locale or version.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Gets the specified version `InteractionModel` of a skill for the vendor. Use `~current` as version parameter to get the current version model.
             * @param {string} skillId The skill ID.
             * @param {string} stageV2 Stages of a skill including the new certified stage. * &#x60;development&#x60; - skills which are currently in development corresponds to this stage. * &#x60;certified&#x60; -  skills which have completed certification and ready for publishing corresponds to this stage. * &#x60;live&#x60; - skills which are currently live corresponds to this stage.
             * @param {string} locale The locale for the model requested e.g. en-GB, en-US, de-DE.
             * @param {string} version Version for interaction model.
             */
            SkillManagementServiceClient.prototype.getInteractionModelVersionV1 = function (skillId, stageV2, locale, version) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetInteractionModelVersionV1(skillId, stageV2, locale, version)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Returns the skill manifest for given skillId and stage.
             * @param {string} skillId The skill ID.
             * @param {string} stageV2 Stages of a skill including the new certified stage. * &#x60;development&#x60; - skills which are currently in development corresponds to this stage. * &#x60;certified&#x60; -  skills which have completed certification and ready for publishing corresponds to this stage. * &#x60;live&#x60; - skills which are currently live corresponds to this stage.
             */
            SkillManagementServiceClient.prototype.callGetSkillManifestV1 = function (skillId, stageV2) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetSkillManifestV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stageV2' is not null or undefined
                                if (stageV2 == null) {
                                    throw new Error("Required parameter stageV2 was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stageV2', stageV2);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/stages/{stageV2}/manifest";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Response contains the latest version of skill manifest.");
                                errorDefinitions.set(303, "See Other");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Returns the skill manifest for given skillId and stage.
             * @param {string} skillId The skill ID.
             * @param {string} stageV2 Stages of a skill including the new certified stage. * &#x60;development&#x60; - skills which are currently in development corresponds to this stage. * &#x60;certified&#x60; -  skills which have completed certification and ready for publishing corresponds to this stage. * &#x60;live&#x60; - skills which are currently live corresponds to this stage.
             */
            SkillManagementServiceClient.prototype.getSkillManifestV1 = function (skillId, stageV2) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetSkillManifestV1(skillId, stageV2)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Updates skill manifest for given skillId and stage.
             * @param {string} skillId The skill ID.
             * @param {string} stageV2 Stages of a skill including the new certified stage. * &#x60;development&#x60; - skills which are currently in development corresponds to this stage. * &#x60;certified&#x60; -  skills which have completed certification and ready for publishing corresponds to this stage. * &#x60;live&#x60; - skills which are currently live corresponds to this stage.
             * @param {v1.skill.Manifest.SkillManifestEnvelope} updateSkillRequest Defines the request body for updateSkill API.
             * @param {string} ifMatch Request header that specified an entity tag. The server will update the resource only if the eTag matches with the resource&#39;s current eTag.
             */
            SkillManagementServiceClient.prototype.callUpdateSkillManifestV1 = function (skillId, stageV2, updateSkillRequest, ifMatch) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callUpdateSkillManifestV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stageV2' is not null or undefined
                                if (stageV2 == null) {
                                    throw new Error("Required parameter stageV2 was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'updateSkillRequest' is not null or undefined
                                if (updateSkillRequest == null) {
                                    throw new Error("Required parameter updateSkillRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (ifMatch != null) {
                                    headerParams.push({ key: 'If-Match', value: ifMatch });
                                }
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stageV2', stageV2);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/stages/{stageV2}/manifest";
                                errorDefinitions = new Map();
                                errorDefinitions.set(202, "Accepted; Returns a URL to track the status in &#39;Location&#39; header.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(409, "The request could not be completed due to a conflict with the current state of the target resource.");
                                errorDefinitions.set(412, "Precondition failed.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("PUT", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, updateSkillRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Updates skill manifest for given skillId and stage.
             * @param {string} skillId The skill ID.
             * @param {string} stageV2 Stages of a skill including the new certified stage. * &#x60;development&#x60; - skills which are currently in development corresponds to this stage. * &#x60;certified&#x60; -  skills which have completed certification and ready for publishing corresponds to this stage. * &#x60;live&#x60; - skills which are currently live corresponds to this stage.
             * @param {v1.skill.Manifest.SkillManifestEnvelope} updateSkillRequest Defines the request body for updateSkill API.
             * @param {string} ifMatch Request header that specified an entity tag. The server will update the resource only if the eTag matches with the resource&#39;s current eTag.
             */
            SkillManagementServiceClient.prototype.updateSkillManifestV1 = function (skillId, stageV2, updateSkillRequest, ifMatch) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callUpdateSkillManifestV1(skillId, stageV2, updateSkillRequest, ifMatch)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * This is an asynchronous API which allows a skill developer to execute various validations against their skill.
             * @param {v1.skill.validations.ValidationsApiRequest} validationsApiRequest Payload sent to the skill validation API.
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             */
            SkillManagementServiceClient.prototype.callSubmitSkillValidationV1 = function (validationsApiRequest, skillId, stage) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callSubmitSkillValidationV1';
                                // verify required parameter 'validationsApiRequest' is not null or undefined
                                if (validationsApiRequest == null) {
                                    throw new Error("Required parameter validationsApiRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stage', stage);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/stages/{stage}/validations";
                                errorDefinitions = new Map();
                                errorDefinitions.set(202, "Skill validation has successfully begun.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "API user does not have permission or is currently in a state that does not allow calls to this API. ");
                                errorDefinitions.set(404, "The specified skill, stage or validation does not exist. The error response will contain a description that indicates the specific resource type that was not found. ");
                                errorDefinitions.set(409, "This requests conflicts with another one currently being processed. ");
                                errorDefinitions.set(429, "API user has exceeded the permitted request rate.");
                                errorDefinitions.set(500, "Internal service error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, validationsApiRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * This is an asynchronous API which allows a skill developer to execute various validations against their skill.
             * @param {v1.skill.validations.ValidationsApiRequest} validationsApiRequest Payload sent to the skill validation API.
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             */
            SkillManagementServiceClient.prototype.submitSkillValidationV1 = function (validationsApiRequest, skillId, stage) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callSubmitSkillValidationV1(validationsApiRequest, skillId, stage)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * This API gets the result of a previously executed validation. A successful response will contain the status of the executed validation. If the validation successfully completed, the response will also contain information related to executed validations. In cases where requests to this API results in an error, the response will contain a description of the problem. In cases where the validation failed, the response will contain a status attribute indicating that a failure occurred. Note that validation results are stored for 60 minutes. A request for an expired validation result will return a 404 HTTP status code.
             * @param {string} skillId The skill ID.
             * @param {string} validationId Id of the validation. Reserved word identifier of mostRecent can be used to get the most recent validation for the skill and stage. Note that the behavior of the API in this case would be the same as when the actual validation id of the most recent validation is used in the request.
             * @param {string} stage Stage for skill.
             * @param {string} acceptLanguage User&#39;s locale/language in context.
             */
            SkillManagementServiceClient.prototype.callGetSkillValidationsV1 = function (skillId, validationId, stage, acceptLanguage) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetSkillValidationsV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'validationId' is not null or undefined
                                if (validationId == null) {
                                    throw new Error("Required parameter validationId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (acceptLanguage != null) {
                                    headerParams.push({ key: 'Accept-Language', value: acceptLanguage });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('validationId', validationId);
                                pathParams.set('stage', stage);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/stages/{stage}/validations/{validationId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Successfully retrieved skill validation information.");
                                errorDefinitions.set(403, "API user does not have permission or is currently in a state that does not allow calls to this API. ");
                                errorDefinitions.set(404, "The specified skill, stage, or validation does not exist. The error response will contain a description that indicates the specific resource type that was not found. ");
                                errorDefinitions.set(409, "This requests conflicts with another one currently being processed. ");
                                errorDefinitions.set(429, "API user has exceeded the permitted request rate.");
                                errorDefinitions.set(500, "Internal service error.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * This API gets the result of a previously executed validation. A successful response will contain the status of the executed validation. If the validation successfully completed, the response will also contain information related to executed validations. In cases where requests to this API results in an error, the response will contain a description of the problem. In cases where the validation failed, the response will contain a status attribute indicating that a failure occurred. Note that validation results are stored for 60 minutes. A request for an expired validation result will return a 404 HTTP status code.
             * @param {string} skillId The skill ID.
             * @param {string} validationId Id of the validation. Reserved word identifier of mostRecent can be used to get the most recent validation for the skill and stage. Note that the behavior of the API in this case would be the same as when the actual validation id of the most recent validation is used in the request.
             * @param {string} stage Stage for skill.
             * @param {string} acceptLanguage User&#39;s locale/language in context.
             */
            SkillManagementServiceClient.prototype.getSkillValidationsV1 = function (skillId, validationId, stage, acceptLanguage) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetSkillValidationsV1(skillId, validationId, stage, acceptLanguage)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Get the status of skill resource and its sub-resources for a given skillId.
             * @param {string} skillId The skill ID.
             * @param {string} resource Resource name for which status information is desired. It is an optional, filtering parameter and can be used more than once, to retrieve status for all the desired (sub)resources only, in single API call. If this parameter is not specified, status for all the resources/sub-resources will be returned.
             */
            SkillManagementServiceClient.prototype.callGetSkillStatusV1 = function (skillId, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, resourceValues, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetSkillStatusV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (resource != null) {
                                    resourceValues = Array.isArray(resource) ? resource : [resource];
                                    resourceValues.forEach(function (val) { return queryParams.push({ key: 'resource', value: val }); });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/status";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns status for skill resource and sub-resources.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Get the status of skill resource and its sub-resources for a given skillId.
             * @param {string} skillId The skill ID.
             * @param {string} resource Resource name for which status information is desired. It is an optional, filtering parameter and can be used more than once, to retrieve status for all the desired (sub)resources only, in single API call. If this parameter is not specified, status for all the resources/sub-resources will be returned.
             */
            SkillManagementServiceClient.prototype.getSkillStatusV1 = function (skillId, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetSkillStatusV1(skillId, resource)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Submit the skill for certification.
             * @param {string} skillId The skill ID.
             * @param {v1.skill.SubmitSkillForCertificationRequest} submitSkillForCertificationRequest Defines the request body for submitSkillForCertification API.
             */
            SkillManagementServiceClient.prototype.callSubmitSkillForCertificationV1 = function (skillId, submitSkillForCertificationRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callSubmitSkillForCertificationV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/submit";
                                errorDefinitions = new Map();
                                errorDefinitions.set(202, "Success. There is no content but returns Location in the header.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, submitSkillForCertificationRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Submit the skill for certification.
             * @param {string} skillId The skill ID.
             * @param {v1.skill.SubmitSkillForCertificationRequest} submitSkillForCertificationRequest Defines the request body for submitSkillForCertification API.
             */
            SkillManagementServiceClient.prototype.submitSkillForCertificationV1 = function (skillId, submitSkillForCertificationRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callSubmitSkillForCertificationV1(skillId, submitSkillForCertificationRequest)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Retrieve a list of all skill versions associated with this skill id
             * @param {string} skillId The skill ID.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             */
            SkillManagementServiceClient.prototype.callListVersionsForSkillV1 = function (skillId, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, nextTokenValues, maxResultsValues, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callListVersionsForSkillV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (nextToken != null) {
                                    nextTokenValues = Array.isArray(nextToken) ? nextToken : [nextToken];
                                    nextTokenValues.forEach(function (val) { return queryParams.push({ key: 'nextToken', value: val }); });
                                }
                                if (maxResults != null) {
                                    maxResultsValues = Array.isArray(maxResults) ? maxResults : [maxResults];
                                    maxResultsValues.forEach(function (val) { return queryParams.push({ key: 'maxResults', value: val.toString() }); });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/versions";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Successfully retrieved skill versions");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Retrieve a list of all skill versions associated with this skill id
             * @param {string} skillId The skill ID.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             */
            SkillManagementServiceClient.prototype.listVersionsForSkillV1 = function (skillId, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callListVersionsForSkillV1(skillId, nextToken, maxResults)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Withdraws the skill from certification.
             * @param {string} skillId The skill ID.
             * @param {v1.skill.WithdrawRequest} withdrawRequest The reason and message (in case of OTHER) to withdraw a skill.
             */
            SkillManagementServiceClient.prototype.callWithdrawSkillFromCertificationV1 = function (skillId, withdrawRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callWithdrawSkillFromCertificationV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'withdrawRequest' is not null or undefined
                                if (withdrawRequest == null) {
                                    throw new Error("Required parameter withdrawRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/{skillId}/withdraw";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Success.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, withdrawRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Withdraws the skill from certification.
             * @param {string} skillId The skill ID.
             * @param {v1.skill.WithdrawRequest} withdrawRequest The reason and message (in case of OTHER) to withdraw a skill.
             */
            SkillManagementServiceClient.prototype.withdrawSkillFromCertificationV1 = function (skillId, withdrawRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callWithdrawSkillFromCertificationV1(skillId, withdrawRequest)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * Creates a new uploadUrl.
             */
            SkillManagementServiceClient.prototype.callCreateUploadUrlV1 = function () {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callCreateUploadUrlV1';
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/skills/uploads";
                                errorDefinitions = new Map();
                                errorDefinitions.set(201, "Created.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Creates a new uploadUrl.
             */
            SkillManagementServiceClient.prototype.createUploadUrlV1 = function () {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callCreateUploadUrlV1()];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Get the list of Vendor information.
             */
            SkillManagementServiceClient.prototype.callGetVendorListV1 = function () {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetVendorListV1';
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/vendors";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Return vendor information on success.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Get the list of Vendor information.
             */
            SkillManagementServiceClient.prototype.getVendorListV1 = function () {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetVendorListV1()];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * Get the current user permissions about Alexa hosted skill features.
             * @param {string} vendorId vendorId
             * @param {string} hostedSkillPermissionType The permission of a hosted skill feature that customer needs to check.
             */
            SkillManagementServiceClient.prototype.callGetAlexaHostedSkillUserPermissionsV1 = function (vendorId, hostedSkillPermissionType) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetAlexaHostedSkillUserPermissionsV1';
                                // verify required parameter 'vendorId' is not null or undefined
                                if (vendorId == null) {
                                    throw new Error("Required parameter vendorId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'hostedSkillPermissionType' is not null or undefined
                                if (hostedSkillPermissionType == null) {
                                    throw new Error("Required parameter hostedSkillPermissionType was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('vendorId', vendorId);
                                pathParams.set('hostedSkillPermissionType', hostedSkillPermissionType);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v1/vendors/{vendorId}/alexaHosted/permissions/{hostedSkillPermissionType}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "response contains the user&#39;s permission of hosted skill features");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error e.g. Authorization Url is invalid");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * Get the current user permissions about Alexa hosted skill features.
             * @param {string} vendorId vendorId
             * @param {string} hostedSkillPermissionType The permission of a hosted skill feature that customer needs to check.
             */
            SkillManagementServiceClient.prototype.getAlexaHostedSkillUserPermissionsV1 = function (vendorId, hostedSkillPermissionType) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetAlexaHostedSkillUserPermissionsV1(vendorId, hostedSkillPermissionType)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * This is a synchronous API that invokes the Lambda or third party HTTPS endpoint for a given skill. A successful response will contain information related to what endpoint was called, payload sent to and received from the endpoint. In cases where requests to this API results in an error, the response will contain an error code and a description of the problem. In cases where invoking the skill endpoint specifically fails, the response will contain a status attribute indicating that a failure occurred and details about what was sent to the endpoint. The skill must belong to and be enabled by the user of this API. Also,  note that calls to the skill endpoint will timeout after 10 seconds. This  API is currently designed in a way that allows extension to an asynchronous  API if a significantly bigger timeout is required.
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             * @param {v2.skill.invocations.InvocationsApiRequest} invocationsApiRequest Payload sent to the skill invocation API.
             */
            SkillManagementServiceClient.prototype.callInvokeSkillEndPointV2 = function (skillId, stage, invocationsApiRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callInvokeSkillEndPointV2';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stage', stage);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v2/skills/{skillId}/stages/{stage}/invocations";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Skill was invoked.");
                                errorDefinitions.set(400, "Bad request due to invalid or missing data.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "API user does not have permission to call this API or is currently in a state that does not allow invocation of this skill. ");
                                errorDefinitions.set(404, "The specified skill does not exist.");
                                errorDefinitions.set(429, "API user has exceeded the permitted request rate.");
                                errorDefinitions.set(500, "Internal service error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, invocationsApiRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * This is a synchronous API that invokes the Lambda or third party HTTPS endpoint for a given skill. A successful response will contain information related to what endpoint was called, payload sent to and received from the endpoint. In cases where requests to this API results in an error, the response will contain an error code and a description of the problem. In cases where invoking the skill endpoint specifically fails, the response will contain a status attribute indicating that a failure occurred and details about what was sent to the endpoint. The skill must belong to and be enabled by the user of this API. Also,  note that calls to the skill endpoint will timeout after 10 seconds. This  API is currently designed in a way that allows extension to an asynchronous  API if a significantly bigger timeout is required.
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             * @param {v2.skill.invocations.InvocationsApiRequest} invocationsApiRequest Payload sent to the skill invocation API.
             */
            SkillManagementServiceClient.prototype.invokeSkillEndPointV2 = function (skillId, stage, invocationsApiRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callInvokeSkillEndPointV2(skillId, stage, invocationsApiRequest)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * This is an asynchronous API that simulates a skill execution in the Alexa eco-system given an utterance text of what a customer would say to Alexa. A successful response will contain a header with the location of the simulation resource. In cases where requests to this API results in an error, the response will contain an error code and a description of the problem. The skill being simulated must belong to and be enabled by the user of this API. Concurrent requests per user is currently not supported.
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             * @param {v2.skill.simulations.SimulationsApiRequest} simulationsApiRequest Payload sent to the skill simulation API.
             */
            SkillManagementServiceClient.prototype.callSimulateSkillV2 = function (skillId, stage, simulationsApiRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callSimulateSkillV2';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'simulationsApiRequest' is not null or undefined
                                if (simulationsApiRequest == null) {
                                    throw new Error("Required parameter simulationsApiRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (!headerParams.find(function (param) { return param.key.toLowerCase() === 'content-type'; })) {
                                    headerParams.push({ key: 'Content-type', value: 'application/json' });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stage', stage);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v2/skills/{skillId}/stages/{stage}/simulations";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Skill simulation has successfully began.");
                                errorDefinitions.set(400, "Bad request due to invalid or missing data.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "API user does not have permission to call this API or is currently in a state that does not allow simulation of this skill. ");
                                errorDefinitions.set(404, "The specified skill does not exist.");
                                errorDefinitions.set(409, "This requests conflicts with another one currently being processed. ");
                                errorDefinitions.set(429, "API user has exceeded the permitted request rate.");
                                errorDefinitions.set(500, "Internal service error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, simulationsApiRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * This is an asynchronous API that simulates a skill execution in the Alexa eco-system given an utterance text of what a customer would say to Alexa. A successful response will contain a header with the location of the simulation resource. In cases where requests to this API results in an error, the response will contain an error code and a description of the problem. The skill being simulated must belong to and be enabled by the user of this API. Concurrent requests per user is currently not supported.
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             * @param {v2.skill.simulations.SimulationsApiRequest} simulationsApiRequest Payload sent to the skill simulation API.
             */
            SkillManagementServiceClient.prototype.simulateSkillV2 = function (skillId, stage, simulationsApiRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callSimulateSkillV2(skillId, stage, simulationsApiRequest)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             * This API gets the result of a previously executed simulation. A successful response will contain the status of the executed simulation. If the simulation successfully completed, the response will also contain information related to skill invocation. In cases where requests to this API results in an error, the response will contain an error code and a description of the problem. In cases where the simulation failed, the response will contain a status attribute indicating that a failure occurred and details about what was sent to the skill endpoint. Note that simulation results are stored for 10 minutes. A request for an expired simulation result will return a 404 HTTP status code.
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             * @param {string} simulationId Id of the simulation.
             */
            SkillManagementServiceClient.prototype.callGetSkillSimulationV2 = function (skillId, stage, simulationId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, resourcePath, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetSkillSimulationV2';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'simulationId' is not null or undefined
                                if (simulationId == null) {
                                    throw new Error("Required parameter simulationId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stage', stage);
                                pathParams.set('simulationId', simulationId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                resourcePath = "/v2/skills/{skillId}/stages/{stage}/simulations/{simulationId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Successfully retrieved skill simulation information.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "API user does not have permission or is currently in a state that does not allow calls to this API. ");
                                errorDefinitions.set(404, "The specified skill or simulation does not exist. The error response will contain a description that indicates the specific resource type that was not found. ");
                                errorDefinitions.set(429, "API user has exceeded the permitted request rate.");
                                errorDefinitions.set(500, "Internal service error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, resourcePath, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             * This API gets the result of a previously executed simulation. A successful response will contain the status of the executed simulation. If the simulation successfully completed, the response will also contain information related to skill invocation. In cases where requests to this API results in an error, the response will contain an error code and a description of the problem. In cases where the simulation failed, the response will contain a status attribute indicating that a failure occurred and details about what was sent to the skill endpoint. Note that simulation results are stored for 10 minutes. A request for an expired simulation result will return a 404 HTTP status code.
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             * @param {string} simulationId Id of the simulation.
             */
            SkillManagementServiceClient.prototype.getSkillSimulationV2 = function (skillId, stage, simulationId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetSkillSimulationV2(skillId, stage, simulationId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            return SkillManagementServiceClient;
        }(BaseServiceClient));
        skillManagement.SkillManagementServiceClient = SkillManagementServiceClient;
    })(skillManagement = services.skillManagement || (services.skillManagement = {}));
})(services = exports.services || (exports.services = {}));
(function (services) {
    /**
     * Helper class that instantiates an ServiceClient implementation automatically resolving its
     * required ApiConfiguration.
     * @export
     * @class ServiceClientFactory
     */
    var ServiceClientFactory = /** @class */ (function () {
        function ServiceClientFactory(apiConfiguration) {
            this.apiConfiguration = apiConfiguration;
        }
        return ServiceClientFactory;
    }());
    services.ServiceClientFactory = ServiceClientFactory;
})(services = exports.services || (exports.services = {}));
//# sourceMappingURL=index.js.map